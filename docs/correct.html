
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Radar Corrections (pyart.correct) &#8212; pyart-mch 0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyart-mch 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Radar Corrections (<code class="docutils literal notranslate"><span class="pre">pyart.correct</span></code>)</a><ul>
<li><a class="reference internal" href="#velocity-unfolding">Velocity unfolding</a></li>
<li><a class="reference internal" href="#other-corrections">Other corrections</a></li>
<li><a class="reference internal" href="#helper-functions">Helper functions</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/correct.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <hr class="docutils" />
<span class="target" id="module-pyart.correct"></span><div class="section" id="radar-corrections-pyart-correct">
<h1>Radar Corrections (<a class="reference internal" href="#module-pyart.correct" title="pyart.correct"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyart.correct</span></code></a>)<a class="headerlink" href="#radar-corrections-pyart-correct" title="Permalink to this headline">¶</a></h1>
<p>Correct radar fields.</p>
<div class="section" id="velocity-unfolding">
<h2>Velocity unfolding<a class="headerlink" href="#velocity-unfolding" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.dealias_fourdd" title="pyart.correct.dealias_fourdd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dealias_fourdd</span></code></a>(radar[,&nbsp;last_radar,&nbsp;…])</td>
<td>Dealias Doppler velocities using the 4DD algorithm.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.dealias_unwrap_phase" title="pyart.correct.dealias_unwrap_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dealias_unwrap_phase</span></code></a>(radar[,&nbsp;unwrap_unit,&nbsp;…])</td>
<td>Dealias Doppler velocities using multi-dimensional phase unwrapping.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.dealias_region_based" title="pyart.correct.dealias_region_based"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dealias_region_based</span></code></a>(radar[,&nbsp;ref_vel_field,&nbsp;…])</td>
<td>Dealias Doppler velocities using a region based algorithm.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="other-corrections">
<h2>Other corrections<a class="headerlink" href="#other-corrections" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.calculate_attenuation" title="pyart.correct.calculate_attenuation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_attenuation</span></code></a>(radar,&nbsp;z_offset[,&nbsp;…])</td>
<td>Calculate the attenuation from a polarimetric radar using Z-PHI method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.calculate_attenuation_zphi" title="pyart.correct.calculate_attenuation_zphi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_attenuation_zphi</span></code></a>(radar[,&nbsp;doc,&nbsp;…])</td>
<td>Calculate the attenuation and the differential attenuation from a polarimetric radar using Z-PHI method..</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.calculate_attenuation_philinear" title="pyart.correct.calculate_attenuation_philinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_attenuation_philinear</span></code></a>(radar[,&nbsp;…])</td>
<td>Calculate the attenuation and the differential attenuation from a polarimetric radar using linear dependece with PhiDP.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.phase_proc_lp" title="pyart.correct.phase_proc_lp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_proc_lp</span></code></a>(radar,&nbsp;offset[,&nbsp;debug,&nbsp;…])</td>
<td>Phase process using a LP method [1].</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.det_sys_phase_ray" title="pyart.correct.det_sys_phase_ray"><code class="xref py py-obj docutils literal notranslate"><span class="pre">det_sys_phase_ray</span></code></a>(radar[,&nbsp;ind_rmin,&nbsp;…])</td>
<td>Public method Alternative determination of the system phase.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.correct_sys_phase" title="pyart.correct.correct_sys_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correct_sys_phase</span></code></a>(radar[,&nbsp;ind_rmin,&nbsp;…])</td>
<td>correction of the system offset.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.smooth_phidp_single_window" title="pyart.correct.smooth_phidp_single_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_phidp_single_window</span></code></a>(radar[,&nbsp;…])</td>
<td>correction of the system offset and smoothing using one window</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.smooth_phidp_double_window" title="pyart.correct.smooth_phidp_double_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_phidp_double_window</span></code></a>(radar[,&nbsp;…])</td>
<td>correction of the system offset and smoothing using two window</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.despeckle_field" title="pyart.correct.despeckle_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">despeckle_field</span></code></a>(radar,&nbsp;field[,&nbsp;label_dict,&nbsp;…])</td>
<td>Despeckle a radar volume by identifying small objects in each scan and masking them out.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.correct_noise_rhohv" title="pyart.correct.correct_noise_rhohv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correct_noise_rhohv</span></code></a>(radar[,&nbsp;urhohv_field,&nbsp;…])</td>
<td>Corrects RhoHV for noise according to eq.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.correct_bias" title="pyart.correct.correct_bias"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correct_bias</span></code></a>(radar[,&nbsp;bias,&nbsp;field_name])</td>
<td>Corrects a radar data bias.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.correct_visibility" title="pyart.correct.correct_visibility"><code class="xref py py-obj docutils literal notranslate"><span class="pre">correct_visibility</span></code></a>(radar[,&nbsp;vis_field,&nbsp;…])</td>
<td>Corrects the reflectivity according to visibility.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.est_rhohv_rain" title="pyart.correct.est_rhohv_rain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rhohv_rain</span></code></a>(radar[,&nbsp;ind_rmin,&nbsp;ind_rmax,&nbsp;…])</td>
<td>Estimates the quantiles of RhoHV in rain for each sweep</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.est_zdr_precip" title="pyart.correct.est_zdr_precip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_zdr_precip</span></code></a>(radar[,&nbsp;ind_rmin,&nbsp;ind_rmax,&nbsp;…])</td>
<td>Filters out all undesired data to be able to estimate ZDR bias, either in moderate rain or from vertically pointing scans</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.est_zdr_snow" title="pyart.correct.est_zdr_snow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_zdr_snow</span></code></a>(radar[,&nbsp;ind_rmin,&nbsp;ind_rmax,&nbsp;…])</td>
<td>Filters out all undesired data to be able to estimate ZDR bias in snow</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.selfconsistency_bias" title="pyart.correct.selfconsistency_bias"><code class="xref py py-obj docutils literal notranslate"><span class="pre">selfconsistency_bias</span></code></a>(radar,&nbsp;zdr_kdpzh_dict)</td>
<td>Estimates reflectivity bias at each ray using the self-consistency algorithm by Gourley</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.selfconsistency_kdp_phidp" title="pyart.correct.selfconsistency_kdp_phidp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">selfconsistency_kdp_phidp</span></code></a>(radar,&nbsp;zdr_kdpzh_dict)</td>
<td>Estimates KDP and PhiDP in rain from  Zh and ZDR using a selfconsistency relation between ZDR, Zh and KDP.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.get_sun_hits" title="pyart.correct.get_sun_hits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sun_hits</span></code></a>(radar[,&nbsp;delev_max,&nbsp;dazim_max,&nbsp;…])</td>
<td>get data from suspected sun hits</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.sun_retrieval" title="pyart.correct.sun_retrieval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sun_retrieval</span></code></a>(az_rad,&nbsp;az_sun,&nbsp;el_rad,&nbsp;…[,&nbsp;…])</td>
<td>Estimates sun parameters from sun hits</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.phase_proc_lp_gf" title="pyart.correct.phase_proc_lp_gf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_proc_lp_gf</span></code></a>(radar[,&nbsp;gatefilter,&nbsp;debug,&nbsp;…])</td>
<td>Phase process using a LP method [1] using Py-ART’s Gatefilter.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="helper-functions">
<h2>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.find_objects" title="pyart.correct.find_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_objects</span></code></a>(radar,&nbsp;field,&nbsp;threshold[,&nbsp;…])</td>
<td>Find objects (i.e., contiguous gates) in one or more sweeps that match thresholds.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.get_mask_fzl" title="pyart.correct.get_mask_fzl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_mask_fzl</span></code></a>(radar[,&nbsp;fzl,&nbsp;doc,&nbsp;min_temp,&nbsp;…])</td>
<td>constructs a mask to mask data placed thickness m below data at min_temp and beyond Parameters ———- radar : Radar     the radar object doc : float     Number of gates at the end of each ray to to remove from the     calculation.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.sun_power" title="pyart.correct.sun_power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sun_power</span></code></a>(solar_flux,&nbsp;pulse_width,&nbsp;wavelen,&nbsp;…)</td>
<td>computes the theoretical sun power detected at the antenna [dBm] as it would be without atmospheric attenuation (sun power at top of the atmosphere) for a given solar flux and radar characteristics</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.ptoa_to_sf" title="pyart.correct.ptoa_to_sf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ptoa_to_sf</span></code></a>(ptoa,&nbsp;pulse_width,&nbsp;wavelen,&nbsp;…)</td>
<td>Converts the sun power at the top of the atmosphere (in dBm) into solar flux.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.solar_flux_lookup" title="pyart.correct.solar_flux_lookup"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solar_flux_lookup</span></code></a>(solar_flux,&nbsp;wavelen)</td>
<td>Given the observed solar flux at 10.7 cm wavelength, returns the solar flux at the given radar wavelength</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.scanning_losses" title="pyart.correct.scanning_losses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scanning_losses</span></code></a>(angle_step,&nbsp;beamwidth)</td>
<td>Given the antenna beam width and the integration angle, compute the losses due to the fact that the sun is not a point target and the antenna is scanning</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.smooth_masked" title="pyart.correct.smooth_masked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth_masked</span></code></a>(raw_data[,&nbsp;wind_len,&nbsp;…])</td>
<td>smoothes the data using a rolling window.</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pyart.correct.GateFilter">
<em class="property">class </em><code class="descclassname">pyart.correct.</code><code class="descname">GateFilter</code><span class="sig-paren">(</span><em>radar</em>, <em>exclude_based=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A class for building a boolean arrays for filtering gates based on
a set of condition typically based on the values in the radar fields.
These filter can be used in various algorithms and calculations within
Py-ART.</p>
<p>See <a class="reference internal" href="#pyart.correct.GateFilter.exclude_below" title="pyart.correct.GateFilter.exclude_below"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyart.correct.GateFilter.exclude_below()</span></code></a> for method
parameter details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object from which gate filter will be build.</p>
</dd>
<dt><strong>exclude_based</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True, the default and suggested method, will begin with all gates
included and then use the exclude methods to exclude gates based on
conditions.  False will begin with all gates excluded from which
a set of gates to include should be set using the include methods.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyart</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radar</span> <span class="o">=</span> <span class="n">pyart</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s1">&#39;radar_file.nc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gatefilter</span> <span class="o">=</span> <span class="n">pyart</span><span class="o">.</span><span class="n">correct</span><span class="o">.</span><span class="n">GateFilter</span><span class="p">(</span><span class="n">radar</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gatefilter</span><span class="o">.</span><span class="n">exclude_below</span><span class="p">(</span><span class="s1">&#39;reflectivity&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gatefilter</span><span class="o">.</span><span class="n">exclude_below</span><span class="p">(</span><span class="s1">&#39;normalized_coherent_power&#39;</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#pyart.correct.GateFilter.gate_excluded" title="pyart.correct.GateFilter.gate_excluded"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gate_excluded</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype=bool</span></dt>
<dd><p class="first last">Return a copy of the excluded gates.</p>
</dd>
<dt><a class="reference internal" href="#pyart.correct.GateFilter.gate_included" title="pyart.correct.GateFilter.gate_included"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gate_included</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype=bool</span></dt>
<dd><p class="first last">Return a copy of the included gates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.copy" title="pyart.correct.GateFilter.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Return a copy of the gatefilter.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_above" title="pyart.correct.GateFilter.exclude_above"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_above</span></code></a>(field,&nbsp;value[,&nbsp;…])</td>
<td>Exclude gates where a given field is above a given value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_all" title="pyart.correct.GateFilter.exclude_all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_all</span></code></a>()</td>
<td>Exclude all gates.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_below" title="pyart.correct.GateFilter.exclude_below"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_below</span></code></a>(field,&nbsp;value[,&nbsp;…])</td>
<td>Exclude gates where a given field is below a given value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_equal" title="pyart.correct.GateFilter.exclude_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_equal</span></code></a>(field,&nbsp;value[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Exclude gates where a given field is equal to a value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_gates" title="pyart.correct.GateFilter.exclude_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_gates</span></code></a>(mask[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Exclude gates where a given mask is equal True.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_inside" title="pyart.correct.GateFilter.exclude_inside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_inside</span></code></a>(field,&nbsp;v1,&nbsp;v2[,&nbsp;…])</td>
<td>Exclude gates where a given field is inside a given interval.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_invalid" title="pyart.correct.GateFilter.exclude_invalid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_invalid</span></code></a>(field[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Exclude gates where an invalid value occurs in a field (NaNs or infs).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_masked" title="pyart.correct.GateFilter.exclude_masked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_masked</span></code></a>(field[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Exclude gates where a given field is masked.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_none" title="pyart.correct.GateFilter.exclude_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_none</span></code></a>()</td>
<td>Exclude no gates, include all gates.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_not_equal" title="pyart.correct.GateFilter.exclude_not_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_not_equal</span></code></a>(field,&nbsp;value[,&nbsp;…])</td>
<td>Exclude gates where a given field is not equal to a value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_outside" title="pyart.correct.GateFilter.exclude_outside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_outside</span></code></a>(field,&nbsp;v1,&nbsp;v2[,&nbsp;…])</td>
<td>Exclude gates where a given field is outside a given interval.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.exclude_transition" title="pyart.correct.GateFilter.exclude_transition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exclude_transition</span></code></a>([trans_value,&nbsp;…])</td>
<td>Exclude all gates in rays marked as in transition between sweeps.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_above" title="pyart.correct.GateFilter.include_above"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_above</span></code></a>(field,&nbsp;value[,&nbsp;…])</td>
<td>Include gates where a given field is above a given value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_all" title="pyart.correct.GateFilter.include_all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_all</span></code></a>()</td>
<td>Include all gates.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_below" title="pyart.correct.GateFilter.include_below"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_below</span></code></a>(field,&nbsp;value[,&nbsp;…])</td>
<td>Include gates where a given field is below a given value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_equal" title="pyart.correct.GateFilter.include_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_equal</span></code></a>(field,&nbsp;value[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Include gates where a given field is equal to a value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_gates" title="pyart.correct.GateFilter.include_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_gates</span></code></a>(mask[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Include gates where a given mask is equal True.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_inside" title="pyart.correct.GateFilter.include_inside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_inside</span></code></a>(field,&nbsp;v1,&nbsp;v2[,&nbsp;…])</td>
<td>Include gates where a given field is inside a given interval.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_none" title="pyart.correct.GateFilter.include_none"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_none</span></code></a>()</td>
<td>Include no gates, exclude all gates.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_not_equal" title="pyart.correct.GateFilter.include_not_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_not_equal</span></code></a>(field,&nbsp;value[,&nbsp;…])</td>
<td>Include gates where a given field is not equal to a value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_not_masked" title="pyart.correct.GateFilter.include_not_masked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_not_masked</span></code></a>(field[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Include gates where a given field in not masked.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_not_transition" title="pyart.correct.GateFilter.include_not_transition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_not_transition</span></code></a>([trans_value,&nbsp;…])</td>
<td>Include all gates in rays not marked as in transition between sweeps.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_outside" title="pyart.correct.GateFilter.include_outside"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_outside</span></code></a>(field,&nbsp;v1,&nbsp;v2[,&nbsp;…])</td>
<td>Include gates where a given field is outside a given interval.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.correct.GateFilter.include_valid" title="pyart.correct.GateFilter.include_valid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">include_valid</span></code></a>(field[,&nbsp;exclude_masked,&nbsp;op])</td>
<td>Include gates where a valid value occurs in a field (not NaN or inf).</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyart.correct.GateFilter.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#pyart.correct.GateFilter.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__delattr__">
<code class="descname">__delattr__</code><span class="sig-paren">(</span><em>$self</em>, <em>name</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement delattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'include_none': &lt;function GateFilter.include_none&gt;, 'include_below': &lt;function GateFilter.include_below&gt;, 'include_inside': &lt;function GateFilter.include_inside&gt;, 'include_outside': &lt;function GateFilter.include_outside&gt;, 'include_above': &lt;function GateFilter.include_above&gt;, 'exclude_outside': &lt;function GateFilter.exclude_outside&gt;, 'exclude_none': &lt;function GateFilter.exclude_none&gt;, 'exclude_not_equal': &lt;function GateFilter.exclude_not_equal&gt;, 'exclude_above': &lt;function GateFilter.exclude_above&gt;, 'gate_excluded': &lt;property object&gt;, '__module__': 'pyart.filters.gatefilter', '__weakref__': &lt;attribute '__weakref__' of 'GateFilter' objects&gt;, 'include_equal': &lt;function GateFilter.include_equal&gt;, 'include_gates': &lt;function GateFilter.include_gates&gt;, 'include_all': &lt;function GateFilter.include_all&gt;, 'include_valid': &lt;function GateFilter.include_valid&gt;, 'include_not_equal': &lt;function GateFilter.include_not_equal&gt;, '__init__': &lt;function GateFilter.__init__&gt;, 'exclude_all': &lt;function GateFilter.exclude_all&gt;, 'exclude_inside': &lt;function GateFilter.exclude_inside&gt;, 'exclude_masked': &lt;function GateFilter.exclude_masked&gt;, 'exclude_invalid': &lt;function GateFilter.exclude_invalid&gt;, '__doc__': &quot;\n    A class for building a boolean arrays for filtering gates based on\n    a set of condition typically based on the values in the radar fields.\n    These filter can be used in various algorithms and calculations within\n    Py-ART.\n\n    See :py:func:`pyart.correct.GateFilter.exclude_below` for method\n    parameter details.\n\n    Parameters\n    ----------\n    radar : Radar\n        Radar object from which gate filter will be build.\n    exclude_based : bool, optional\n        True, the default and suggested method, will begin with all gates\n        included and then use the exclude methods to exclude gates based on\n        conditions.  False will begin with all gates excluded from which\n        a set of gates to include should be set using the include methods.\n\n    Attributes\n    ----------\n    gate_excluded : array, dtype=bool\n        Boolean array indicating if a gate should be excluded from a\n        calculation. Elements marked True indicate the corresponding gate\n        should be excluded.  Those marked False should be included.\n        This is read-only attribute, any changes to the array will NOT\n        be reflected in gate_included and will be lost when the attribute is\n        accessed again.\n    gate_included : array, dtype=bool\n        Boolean array indicating if a gate should be included in a\n        calculation. Elements marked True indicate the corresponding gate\n        should be include.  Those marked False should be excluded.\n        This is read-only attribute, any changes to the array will NOT\n        be reflected in gate_excluded and will be lost when the attribute is\n        accessed again.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pyart\n    &gt;&gt;&gt; radar = pyart.io.read('radar_file.nc')\n    &gt;&gt;&gt; gatefilter = pyart.correct.GateFilter(radar)\n    &gt;&gt;&gt; gatefilter.exclude_below('reflectivity', 10)\n    &gt;&gt;&gt; gatefilter.exclude_below('normalized_coherent_power', 0.75)\n\n    &quot;, '_merge': &lt;function GateFilter._merge&gt;, 'include_not_masked': &lt;function GateFilter.include_not_masked&gt;, 'exclude_below': &lt;function GateFilter.exclude_below&gt;, 'exclude_gates': &lt;function GateFilter.exclude_gates&gt;, 'exclude_equal': &lt;function GateFilter.exclude_equal&gt;, '__dict__': &lt;attribute '__dict__' of 'GateFilter' objects&gt;, 'gate_included': &lt;property object&gt;, 'copy': &lt;function GateFilter.copy&gt;, 'exclude_transition': &lt;function GateFilter.exclude_transition&gt;, 'include_not_transition': &lt;function GateFilter.include_not_transition&gt;, '_get_fdata': &lt;function GateFilter._get_fdata&gt;})</em><a class="headerlink" href="#pyart.correct.GateFilter.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; list<a class="headerlink" href="#pyart.correct.GateFilter.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>default dir() implementation</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__eq__">
<code class="descname">__eq__</code><span class="sig-paren">(</span><em>$self</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self==value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>default object formatter</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__ge__">
<code class="descname">__ge__</code><span class="sig-paren">(</span><em>$self</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__getattribute__">
<code class="descname">__getattribute__</code><span class="sig-paren">(</span><em>$self</em>, <em>name</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return getattr(self, name).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__gt__">
<code class="descname">__gt__</code><span class="sig-paren">(</span><em>$self</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&gt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return hash(self).</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>radar</em>, <em>exclude_based=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__le__">
<code class="descname">__le__</code><span class="sig-paren">(</span><em>$self</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;=value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__lt__">
<code class="descname">__lt__</code><span class="sig-paren">(</span><em>$self</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self&lt;value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__module__">
<code class="descname">__module__</code><em class="property"> = 'pyart.filters.gatefilter'</em><a class="headerlink" href="#pyart.correct.GateFilter.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__ne__">
<code class="descname">__ne__</code><span class="sig-paren">(</span><em>$self</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return self!=value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><em>$type</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__new__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a new object.  See help(type) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for pickle</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for pickle</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>$self</em>, <em>name</em>, <em>value</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement setattr(self, name, value).</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pyart.correct.GateFilter.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd><p>size of object in memory, in bytes</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><em>$self</em>, <em>/</em><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyart.correct.GateFilter.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#pyart.correct.GateFilter.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter._get_fdata">
<code class="descname">_get_fdata</code><span class="sig-paren">(</span><em>field</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter._get_fdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter._get_fdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that the field exists and retrieve field data.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter._merge">
<code class="descname">_merge</code><span class="sig-paren">(</span><em>marked</em>, <em>op</em>, <em>exclude_masked</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter._merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter._merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge an array of marked gates with the exclude array.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the gatefilter.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_above">
<code class="descname">exclude_above</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='or'</em>, <em>inclusive=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_above"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_above" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is above a given value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_all">
<code class="descname">exclude_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude all gates.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_below">
<code class="descname">exclude_below</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='or'</em>, <em>inclusive=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_below"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_below" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is below a given value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of field compared against the value.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Gates with a value below this value in the specified field will
be marked for exclusion in the filter.</p>
</dd>
<dt><strong>exclude_masked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to filter masked values in the specified field if the data is
a masked array, False to include any masked values.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘and’, ‘or’, ‘new’}</span></dt>
<dd><p class="first last">Operation to perform when merging the existing set of excluded
gates with the excluded gates from the current operation.
‘and’ will perform a logical AND operation, ‘or’ a logical OR,
and ‘new’ will replace the existing excluded gates with the one
generated here. ‘or’, the default for exclude methods, is
typically desired when building up a set of conditions for
excluding gates where the desired effect is to exclude gates which
meet any of the conditions. ‘and’, the default for include
methods, is typically desired when building up a set of conditions
where the desired effect is to include gates which meet any of the
conditions.  Note that the ‘and’ method MAY results in including
gates which have previously been excluded because they were masked
or invalid.</p>
</dd>
<dt><strong>inclusive</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates whether the specified value should also be excluded.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_equal">
<code class="descname">exclude_equal</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='or'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is equal to a value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_gates">
<code class="descname">exclude_gates</code><span class="sig-paren">(</span><em>mask</em>, <em>exclude_masked=True</em>, <em>op='or'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given mask is equal True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd><p class="first last">Boolean numpy array with same shape as a field array.</p>
</dd>
<dt><strong>exclude_masked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to filter masked values in the specified mask if it is
a masked array, False to include any masked values.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘and’, ‘or’, ‘new’}</span></dt>
<dd><p class="first last">Operation to perform when merging the existing set of excluded
gates with the excluded gates from the current operation.
‘and’ will perform a logical AND operation, ‘or’ a logical OR,
and ‘new’ will replace the existing excluded gates with the one
generated here. ‘or’, the default for exclude methods, is
typically desired when building up a set of conditions for
excluding gates where the desired effect is to exclude gates which
meet any of the conditions. ‘and’, the default for include
methods, is typically desired when building up a set of conditions
where the desired effect is to include gates which meet any of the
conditions.  Note that the ‘and’ method MAY results in including
gates which have previously been excluded because they were masked
or invalid.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_inside">
<code class="descname">exclude_inside</code><span class="sig-paren">(</span><em>field</em>, <em>v1</em>, <em>v2</em>, <em>exclude_masked=True</em>, <em>op='or'</em>, <em>inclusive=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_inside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is inside a given interval.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_invalid">
<code class="descname">exclude_invalid</code><span class="sig-paren">(</span><em>field</em>, <em>exclude_masked=True</em>, <em>op='or'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_invalid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_invalid" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where an invalid value occurs in a field (NaNs or infs).</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_masked">
<code class="descname">exclude_masked</code><span class="sig-paren">(</span><em>field</em>, <em>exclude_masked=True</em>, <em>op='or'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_masked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is masked.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_none">
<code class="descname">exclude_none</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude no gates, include all gates.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_not_equal">
<code class="descname">exclude_not_equal</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='or'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_not_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is not equal to a value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_outside">
<code class="descname">exclude_outside</code><span class="sig-paren">(</span><em>field</em>, <em>v1</em>, <em>v2</em>, <em>exclude_masked=True</em>, <em>op='or'</em>, <em>inclusive=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_outside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_outside" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude gates where a given field is outside a given interval.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.exclude_transition">
<code class="descname">exclude_transition</code><span class="sig-paren">(</span><em>trans_value=1</em>, <em>exclude_masked=True</em>, <em>op='or'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.exclude_transition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.exclude_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude all gates in rays marked as in transition between sweeps.</p>
<p>Exclude all gates in rays marked as “in transition” by the
antenna_transition attribute of the radar used to construct the filter.
If no antenna transition information is available no gates are
excluded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trans_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Value used in the antenna transition data to indicate that the
instrument was between sweeps (in transition) during the collection
of a specific ray. Typically a value of 1 is used to indicate this
transition and the default can be used in these cases.</p>
</dd>
<dt><strong>exclude_masked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to filter masked values in antenna_transition if the data is
a masked array, False to include any masked values.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘and’, ‘or’, ‘new’}</span></dt>
<dd><p class="first last">Operation to perform when merging the existing set of excluded
gates with the excluded gates from the current operation.
‘and’ will perform a logical AND operation, ‘or’ a logical OR,
and ‘new’ will replace the existing excluded gates with the one
generated here. ‘or’, the default for exclude methods, is
typically desired when building up a set of conditions for
excluding gates where the desired effect is to exclude gates which
meet any of the conditions. ‘and’, the default for include
methods, is typically desired when building up a set of conditions
where the desired effect is to include gates which meet any of the
conditions.  Note that the ‘and’ method MAY results in including
gates which have previously been excluded because they were masked
or invalid.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.gate_excluded">
<code class="descname">gate_excluded</code><a class="headerlink" href="#pyart.correct.GateFilter.gate_excluded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the excluded gates.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyart.correct.GateFilter.gate_included">
<code class="descname">gate_included</code><a class="headerlink" href="#pyart.correct.GateFilter.gate_included" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the included gates.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_above">
<code class="descname">include_above</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='and'</em>, <em>inclusive=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_above"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_above" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field is above a given value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_all">
<code class="descname">include_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Include all gates.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_below">
<code class="descname">include_below</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='and'</em>, <em>inclusive=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_below"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_below" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field is below a given value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_equal">
<code class="descname">include_equal</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='and'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field is equal to a value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_gates">
<code class="descname">include_gates</code><span class="sig-paren">(</span><em>mask</em>, <em>exclude_masked=True</em>, <em>op='and'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given mask is equal True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd><p class="first last">Boolean numpy array with same shape as a field array.</p>
</dd>
<dt><strong>exclude_masked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to filter masked values in the specified mask if it is
a masked array, False to include any masked values.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘and’, ‘or’, ‘new’}</span></dt>
<dd><p class="first last">Operation to perform when merging the existing set of excluded
gates with the excluded gates from the current operation.
‘and’ will perform a logical AND operation, ‘or’ a logical OR,
and ‘new’ will replace the existing excluded gates with the one
generated here. ‘or’, the default for exclude methods, is
typically desired when building up a set of conditions for
excluding gates where the desired effect is to exclude gates which
meet any of the conditions. ‘and’, the default for include
methods, is typically desired when building up a set of conditions
where the desired effect is to include gates which meet any of the
conditions.  Note that the ‘or’ method MAY results in excluding
gates which have previously been included.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_inside">
<code class="descname">include_inside</code><span class="sig-paren">(</span><em>field</em>, <em>v1</em>, <em>v2</em>, <em>exclude_masked=True</em>, <em>op='and'</em>, <em>inclusive=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_inside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field is inside a given interval.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_none">
<code class="descname">include_none</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Include no gates, exclude all gates.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_not_equal">
<code class="descname">include_not_equal</code><span class="sig-paren">(</span><em>field</em>, <em>value</em>, <em>exclude_masked=True</em>, <em>op='and'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_not_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field is not equal to a value.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_not_masked">
<code class="descname">include_not_masked</code><span class="sig-paren">(</span><em>field</em>, <em>exclude_masked=True</em>, <em>op='and'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_not_masked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_not_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field in not masked.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_not_transition">
<code class="descname">include_not_transition</code><span class="sig-paren">(</span><em>trans_value=0</em>, <em>exclude_masked=True</em>, <em>op='and'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_not_transition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_not_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Include all gates in rays not marked as in transition between sweeps.</p>
<p>Include all gates in rays not marked as “in transition” by the
antenna_transition attribute of the radar used to construct the filter.
If no antenna transition information is available all gates are
included.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trans_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Value used in the antenna transition data to indicate that the
instrument is not between sweeps (in transition) during the
collection of a specific ray. Typically a value of 0 is used to
indicate no transition and the default can be used in these cases.</p>
</dd>
<dt><strong>exclude_masked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to filter masked values in antenna_transition if the data is
a masked array, False to include any masked values.</p>
</dd>
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘and’, ‘or’, ‘new’}</span></dt>
<dd><p class="first last">Operation to perform when merging the existing set of excluded
gates with the excluded gates from the current operation.
‘and’ will perform a logical AND operation, ‘or’ a logical OR,
and ‘new’ will replace the existing excluded gates with the one
generated here. ‘or’, the default for exclude methods, is
typically desired when building up a set of conditions for
excluding gates where the desired effect is to exclude gates which
meet any of the conditions. ‘and’, the default for include
methods, is typically desired when building up a set of conditions
where the desired effect is to include gates which meet any of the
conditions.  Note that the ‘or’ method MAY results in excluding
gates which have previously been included.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_outside">
<code class="descname">include_outside</code><span class="sig-paren">(</span><em>field</em>, <em>v1</em>, <em>v2</em>, <em>exclude_masked=True</em>, <em>op='and'</em>, <em>inclusive=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_outside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_outside" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a given field is outside a given interval.</p>
</dd></dl>

<dl class="method">
<dt id="pyart.correct.GateFilter.include_valid">
<code class="descname">include_valid</code><span class="sig-paren">(</span><em>field</em>, <em>exclude_masked=True</em>, <em>op='and'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#GateFilter.include_valid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.GateFilter.include_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Include gates where a valid value occurs in a field (not NaN or inf).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pyart.correct.calculate_attenuation">
<code class="descclassname">pyart.correct.</code><code class="descname">calculate_attenuation</code><span class="sig-paren">(</span><em>radar</em>, <em>z_offset</em>, <em>debug=False</em>, <em>doc=15</em>, <em>fzl=4000.0</em>, <em>rhv_min=0.8</em>, <em>ncp_min=0.5</em>, <em>a_coef=0.06</em>, <em>beta=0.8</em>, <em>refl_field=None</em>, <em>ncp_field=None</em>, <em>rhv_field=None</em>, <em>phidp_field=None</em>, <em>spec_at_field=None</em>, <em>corr_refl_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/attenuation.html#calculate_attenuation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.calculate_attenuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the attenuation from a polarimetric radar using Z-PHI method.
Parameters
———-
radar : Radar</p>
<blockquote>
<div>Radar object to use for attenuation calculations.  Must have
copol_coeff, norm_coherent_power, proc_dp_phase_shift,
reflectivity_horizontal fields.</div></blockquote>
<dl class="docutils">
<dt>z_offset <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Horizontal reflectivity offset in dBZ.</dd>
<dt>debug <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True to print debugging information, False supressed this printing.</dd>
</dl>
<dl class="docutils">
<dt>spec_at <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the specific attenuation.</dd>
<dt>cor_z <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the corrected reflectivity.</dd>
</dl>
<dl class="docutils">
<dt>doc <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Number of gates at the end of each ray to to remove from the
calculation.</dd>
<dt>fzl <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Freezing layer, gates above this point are not included in the
correction.</dd>
<dt>rhv_min <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Minimum copol_coeff value to consider valid.</dd>
<dt>ncp_min <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Minimum norm_coherent_power to consider valid.</dd>
<dt>a_coef <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>A coefficient in attenuation calculation.</dd>
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Beta parameter in attenuation calculation.</dd>
<dt>refl_field, ncp_field, rhv_field, phidp_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Field names within the radar object which represent the horizonal
reflectivity, normal coherent power, the copolar coefficient, and the
differential phase shift. A value of None for any of these parameters
will use the default field name as defined in the Py-ART
configuration file.</dd>
<dt>spec_at_field, corr_refl_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Names of the specific attenuation and the corrected
reflectivity fields that will be used to fill in the metadata for
the returned fields.  A value of None for any of these parameters
will use the default field names as defined in the Py-ART
configuration file.</dd>
</dl>
<p>Gu et al. Polarimetric Attenuation Correction in Heavy Rain at C Band,
JAMC, 2011, 50, 39-58.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.calculate_attenuation_philinear">
<code class="descclassname">pyart.correct.</code><code class="descname">calculate_attenuation_philinear</code><span class="sig-paren">(</span><em>radar</em>, <em>doc=None</em>, <em>fzl=None</em>, <em>pia_coef=None</em>, <em>pida_coef=None</em>, <em>refl_field=None</em>, <em>phidp_field=None</em>, <em>zdr_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>spec_at_field=None</em>, <em>pia_field=None</em>, <em>corr_refl_field=None</em>, <em>spec_diff_at_field=None</em>, <em>pida_field=None</em>, <em>corr_zdr_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/attenuation.html#calculate_attenuation_philinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.calculate_attenuation_philinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the attenuation and the differential attenuation from a
polarimetric radar using linear dependece with PhiDP.
The attenuation is computed up to a user defined freezing level height,
where temperatures in a temperature field are positive or where the height
relative to the iso0 is 0.
The coefficients are either user-defined or radar frequency dependent.
Parameters
———-
radar : Radar</p>
<blockquote>
<div>Radar object to use for attenuation calculations.  Must have
phidp and refl fields.</div></blockquote>
<dl class="docutils">
<dt>doc <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Number of gates at the end of each ray to to remove from the
calculation.</dd>
<dt>fzl <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Freezing layer, gates above this point are not included in the
correction.</dd>
<dt>pia_coef <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Coefficient in path integrated attenuation calculation</dd>
<dt>pida_coeff <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Coefficient in path integrated differential attenuation calculation</dd>
<dt>refl_field, phidp_field, zdr_field, temp_field, is0_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Field names within the radar object which represent the horizonal
reflectivity, the differential phase shift, the differential
reflectivity, the temperature and the height over the iso0. A value of
None for any of these parameters will use the default field name as
defined in the Py-ART configuration file. The ZDR field and
temperature field are going to be used only if available.</dd>
<dt>spec_at_field, pia_field, corr_refl_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Names of the specific attenuation, the path integrated attenuation and
the corrected reflectivity fields that will be used to fill in the
metadata for the returned fields.  A value of None for any of these
parameters will use the default field names as defined in the Py-ART
configuration file.</dd>
<dt>spec_diff_at_field, pida_field, corr_zdr_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Names of the specific differential attenuation, the path integrated
differential attenuation and the corrected differential reflectivity
fields that will be used to fill in the metadata for the returned
fields.  A value of None for any of these parameters will use the
default field names as defined in the Py-ART configuration file. These
fields will be computed only if the ZDR field is available.</dd>
<dt>temp_ref <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>the field use as reference for temperature. Can be either temperature,
height_over_iso0 or fixed_fzl</dd>
</dl>
<dl class="docutils">
<dt>spec_at <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the specific attenuation.</dd>
<dt>pia_dict <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the path integrated attenuation.</dd>
<dt>cor_z <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the corrected reflectivity.</dd>
<dt>spec_diff_at <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the specific differential attenuation.</dd>
<dt>pida_dict <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the path integrated differential
attenuation.</dd>
<dt>cor_zdr <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>Field dictionary containing the corrected differential reflectivity.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.calculate_attenuation_zphi">
<code class="descclassname">pyart.correct.</code><code class="descname">calculate_attenuation_zphi</code><span class="sig-paren">(</span><em>radar</em>, <em>doc=None</em>, <em>fzl=None</em>, <em>smooth_window_len=5</em>, <em>a_coef=None</em>, <em>beta=None</em>, <em>c=None</em>, <em>d=None</em>, <em>refl_field=None</em>, <em>phidp_field=None</em>, <em>zdr_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>spec_at_field=None</em>, <em>pia_field=None</em>, <em>corr_refl_field=None</em>, <em>spec_diff_at_field=None</em>, <em>pida_field=None</em>, <em>corr_zdr_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/attenuation.html#calculate_attenuation_zphi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.calculate_attenuation_zphi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the attenuation and the differential attenuation from a
polarimetric radar using Z-PHI method..
The attenuation is computed up to a user defined freezing level height
or up to where temperatures in a temperature field are positive.
The coefficients are either user-defined or radar frequency dependent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object to use for attenuation calculations.  Must have
phidp and refl fields.</p>
</dd>
<dt><strong>doc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number of gates at the end of each ray to to remove from the
calculation.</p>
</dd>
<dt><strong>fzl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Freezing layer, gates above this point are not included in the
correction.</p>
</dd>
<dt><strong>smooth_window_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Size, in range bins, of the smoothing window</p>
</dd>
<dt><strong>a_coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">A coefficient in attenuation calculation.</p>
</dd>
<dt><strong>beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Beta parameter in attenuation calculation.</p>
</dd>
<dt><strong>c, d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">coefficient and exponent of the power law that relates attenuation
with differential attenuation</p>
</dd>
<dt><strong>refl_field, phidp_field, zdr_field, temp_field, iso0_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the horizonal
reflectivity, the differential phase shift, the differential
reflectivity, the temperature field and the height over iso0. A value
of None for any of these parameters will use the default field name as
defined in the Py-ART configuration file. The ZDR field and
temperature field or iso0 field are going to be used only if available.</p>
</dd>
<dt><strong>spec_at_field, pia_field, corr_refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the specific attenuation, path integrated attenuation and the
corrected reflectivity fields that will be used to fill in the
metadata for the returned fields.  A value of None for any of these
parameters will use the default field names as defined in the Py-ART
configuration file.</p>
</dd>
<dt><strong>spec_diff_at_field, pida_field, corr_zdr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the specific differential attenuation, the path integrated
differential attenuation and the corrected differential reflectivity
fields that will be used to fill in the metadata for the returned
fields.  A value of None for any of these parameters will use the
default field names as defined in the Py-ART configuration file.
These fields will be computed only if the ZDR field is available.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be either temperature,
height_over_iso0 or fixed_fzl</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spec_at</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the specific attenuation.</p>
</dd>
<dt><strong>pia_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the path integrated attenuation.</p>
</dd>
<dt><strong>cor_z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the corrected reflectivity.</p>
</dd>
<dt><strong>spec_diff_at</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the specific differential attenuation.</p>
</dd>
<dt><strong>pida_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the path integrated differential
attenuation.</p>
</dd>
<dt><strong>cor_zdr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the corrected differential reflectivity.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Gu et al. Polarimetric Attenuation Correction in Heavy Rain at C Band,
JAMC, 2011, 50, 39-58.</p>
<p>Ryzhkov et al. Potential Utilization of Specific Attenuation for Rainfall
Estimation, Mitigation of Partial Beam Blockage, and Radar Networking,
JAOT, 2014, 31, 599-619.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.correct_bias">
<code class="descclassname">pyart.correct.</code><code class="descname">correct_bias</code><span class="sig-paren">(</span><em>radar</em>, <em>bias=0.0</em>, <em>field_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#correct_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.correct_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects a radar data bias. If field name is none the correction is
applied to horizontal reflectivity by default</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the bias magnitude</p>
</dd>
<dt><strong>field_name: str</strong></dt>
<dd><p class="first last">names of the field to be corrected</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corrected_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The corrected field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.correct_noise_rhohv">
<code class="descclassname">pyart.correct.</code><code class="descname">correct_noise_rhohv</code><span class="sig-paren">(</span><em>radar</em>, <em>urhohv_field=None</em>, <em>snr_field=None</em>, <em>zdr_field=None</em>, <em>nh_field=None</em>, <em>nv_field=None</em>, <em>rhohv_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#correct_noise_rhohv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.correct_noise_rhohv" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects RhoHV for noise according to eq. 6 in Gourley et al. 2006.
This correction should only be performed if noise has not been subtracted
from the signal during the moments computation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>urhohv_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the RhoHV uncorrected for noise field</p>
</dd>
<dt><strong>snr_field, zdr_field, nh_field, nv_field: str</strong></dt>
<dd><p class="first last">names of the SNR, ZDR, horizontal channel noise in dBZ and vertical
channel noise in dBZ used to correct RhoHV</p>
</dd>
<dt><strong>rhohv_field: str</strong></dt>
<dd><p class="first last">name of the rhohv field to output</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rhohv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">noise corrected RhoHV field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Gourley et al. Data Quality of the Meteo-France C-Band Polarimetric
Radar, JAOT, 23, 1340-1356</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.correct_sys_phase">
<code class="descclassname">pyart.correct.</code><code class="descname">correct_sys_phase</code><span class="sig-paren">(</span><em>radar</em>, <em>ind_rmin=10</em>, <em>ind_rmax=500</em>, <em>min_rcons=11</em>, <em>zmin=20.0</em>, <em>zmax=40.0</em>, <em>psidp_field=None</em>, <em>refl_field=None</em>, <em>phidp_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#correct_sys_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.correct_sys_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>correction of the system offset. Public method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object for which to determine the system phase.</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for continuous precipitation</p>
</dd>
<dt><strong>min_rcons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The minimum number of consecutive gates to consider it a rain cell.</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum reflectivity to consider it a rain cell</p>
</dd>
<dt><strong>psidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the differential
phase shift. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the reflectivity.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the corrected
differential phase shift. A value of None will use the default field
name as defined in the Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phidp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The corrected phidp field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.correct_visibility">
<code class="descclassname">pyart.correct.</code><code class="descname">correct_visibility</code><span class="sig-paren">(</span><em>radar</em>, <em>vis_field=None</em>, <em>field_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#correct_visibility"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.correct_visibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects the reflectivity according to visibility.
Applied to horizontal reflectivity by default</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>vis_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the name of the visibility field</p>
</dd>
<dt><strong>field_name: str</strong></dt>
<dd><p class="first last">names of the field to be corrected</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corrected_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The corrected field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.dealias_fourdd">
<code class="descclassname">pyart.correct.</code><code class="descname">dealias_fourdd</code><span class="sig-paren">(</span><em>radar</em>, <em>last_radar=None</em>, <em>sonde_profile=None</em>, <em>gatefilter=False</em>, <em>filt=1</em>, <em>rsl_badval=131072.0</em>, <em>keep_original=False</em>, <em>set_limits=True</em>, <em>vel_field=None</em>, <em>corr_vel_field=None</em>, <em>last_vel_field=None</em>, <em>debug=False</em>, <em>max_shear=0.05</em>, <em>sign=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/dealias.html#dealias_fourdd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.dealias_fourdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Dealias Doppler velocities using the 4DD algorithm.</p>
<p>Dealias the Doppler velocities field using the University of Washington
4DD algorithm utilizing information from a previous volume scan and/or
sounding data. Either last_radar or sonde_profile must be provided.
For best results provide both a previous volume scan and sounding data.
Radar and last_radar must contain the same number of rays per sweep.</p>
<p>Additional arguments are passed to
<code class="xref py py-func docutils literal notranslate"><span class="pre">_fourdd_interface.fourdd_dealias()</span></code>.
These can be used to fine tune the behavior of the FourDD algorithm.
See the documentation of Other Parameters for details.  For the default
values of these parameters see the documentation of
<code class="xref py py-func docutils literal notranslate"><span class="pre">_fourdd_interface.fourdd_dealias()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object to use for dealiasing.  Must have a Nyquist defined in
the instrument_parameters attribute and have a
reflectivity_horizontal and mean_doppler_velocity fields.</p>
</dd>
<dt><strong>last_radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar, optional</span></dt>
<dd><p class="first last">The previous radar volume, which has been successfully
dealiased. Using a previous volume as an initial condition can
greatly improve the dealiasing, and represents the final dimension
in the 4DD algorithm.</p>
</dd>
<dt><strong>sonde_profile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">HorizontalWindProfile</span></dt>
<dd><p class="first last">Profile of horizontal winds from a sonding used for the initial
condition of the dealiasing.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vr_corr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing dealiased Doppler velocities.  Dealiased
array is stored under the ‘data’ key.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter, optional.</span></dt>
<dd><p class="first last">A GateFilter instance which specifies which gates should be
ignored when performing velocity dealiasing.  A value of None will
create this filter from the radar moments using any additional
arguments by passing them to <a class="reference internal" href="#pyart.correct.moment_based_gate_filter" title="pyart.correct.moment_based_gate_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">moment_based_gate_filter()</span></code></a>. The
default value assumes all gates are valid.</p>
</dd>
<dt><strong>filt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Flag controlling Bergen and Albers filter, 1 = yes, 0 = no.</p>
</dd>
<dt><strong>rsl_badval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value which represents a bad value in RSL.</p>
</dd>
<dt><strong>keep_original</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to keep original doppler velocity values when the dealiasing
procedure fails, otherwise these gates will be masked.  NaN values
are still masked.</p>
</dd>
<dt><strong>set_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to set valid_min and valid_max elements in the returned
dictionary.  False will not set these dictionary elements.</p>
</dd>
<dt><strong>vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Field in radar to use as the Doppler velocities during dealiasing.
None will use the default field name from the Py-ART configuration
file.</p>
</dd>
<dt><strong>corr_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name to use for the dealiased Doppler velocity field metadata.  None
will use the default field name from the Py-ART configuration file.</p>
</dd>
<dt><strong>last_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name to use for the dealiased Doppler velocity field metadata in
last_radar.  None will use the corr_vel_field name.</p>
</dd>
<dt><strong>maxshear</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Maximum vertical shear which will be incorporated into the created
volume from the sounding data.  Parameter not used when no
sounding data is provided.</p>
</dd>
<dt><strong>sign</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Sign convention which the radial velocities in the volume created
from the sounding data will will. This should match the convention
used in the radar data. A value of 1 represents when positive values
velocities are towards the radar, -1 represents when negative
velocities are towards the radar.</p>
</dd>
<dt><strong>compthresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Fraction of the Nyquist velocity to use as a threshold when performing
continuity (initial) dealiasing.  Velocities differences above this
threshold will not be marked as gate from which to begin unfolding
during spatial dealiasing.</p>
</dd>
<dt><strong>compthresh2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The same as compthresh but the value used during the second pass of
dealiasing.  This second pass is only performed in both a sounding
and last volume are provided.</p>
</dd>
<dt><strong>thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Fraction of the Nyquist velocity to use as a threshold when performing
spatial dealiasing.  Horizontally adjacent gates with velocities above
this threshold will count against assigning the gate in question the
velocity value being tested.</p>
</dd>
<dt><strong>ckval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">When the absolute value of the velocities are below this value they
will not be marked as gates from which to begin unfolding during
spatial dealiasing.</p>
</dd>
<dt><strong>stdthresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Fraction of the Nyquist velocity to use as a standard deviation
threshold in the window dealiasing portion of the algorithm.</p>
</dd>
<dt><strong>epsilon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Difference used when comparing a value to missing value, changing this
from the default is not recommended.</p>
</dd>
<dt><strong>maxcount</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum allowed number of fold allowed when unfolding velocities.</p>
</dd>
<dt><strong>pass2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Controls weather unfolded gates should be removed (a value of 0)
or retained for unfolding during the second pass (a value of 1) when
both a sounding volume and last volume are provided.</p>
</dd>
<dt><strong>rm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Determines what should be done with gates that are left unfolded
after the first pass of dealiasing.  A value of 1 will remove these
gates, a value of 0 sets these gates to their initial velocity.  If
both a sounding volume and last volume are provided this parameter is
ignored.</p>
</dd>
<dt><strong>proximity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of gates and rays to include of either side of the current gate
during window dealiasing.  This value may be doubled in cases where
a standard sized window does not capture a sufficient number of
good valued gates.</p>
</dd>
<dt><strong>mingood</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of good valued gates required within the window before the
current gate will be unfolded.</p>
</dd>
<dt><strong>ba_mincount</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of neighbors required during Bergen and Albers filter for
a given gate to be included, must be between 1 and 8, 5 recommended.</p>
</dd>
<dt><strong>ba_edgecount</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Same as ba_mincount but used at ray edges, must be between 1 and 5,
3 recommended.</p>
</dd>
<dt><strong>debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Set True to return RSL Volume objects for debugging:
usuccess, radialVelVolume, lastVelVolume, unfoldedVolume, sondVolume</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Due to limitations in the C code do not call with sounding arrays over
999 elements long.</p>
<p class="rubric">References</p>
<p>C. N. James and R. A Houze Jr, A Real-Time Four-Dimensional Doppler
Dealising Scheme, Journal of Atmospheric and Oceanic Technology, 2001, 18,
1674.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.dealias_region_based">
<code class="descclassname">pyart.correct.</code><code class="descname">dealias_region_based</code><span class="sig-paren">(</span><em>radar</em>, <em>ref_vel_field=None</em>, <em>interval_splits=3</em>, <em>interval_limits=None</em>, <em>skip_between_rays=100</em>, <em>skip_along_ray=100</em>, <em>centered=True</em>, <em>nyquist_vel=None</em>, <em>check_nyquist_uniform=True</em>, <em>gatefilter=False</em>, <em>rays_wrap_around=None</em>, <em>keep_original=False</em>, <em>set_limits=True</em>, <em>vel_field=None</em>, <em>corr_vel_field=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/region_dealias.html#dealias_region_based"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.dealias_region_based" title="Permalink to this definition">¶</a></dt>
<dd><p>Dealias Doppler velocities using a region based algorithm.</p>
<p>Performs Doppler velocity dealiasing by finding regions of similar
velocities and unfolding and merging pairs of regions until all
regions are unfolded.  Unfolding and merging regions is accomplished by
modeling the problem as a dynamic network reduction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object containing Doppler velocities to dealias.</p>
</dd>
<dt><strong>ref_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None, optional</span></dt>
<dd><p class="first last">Field in radar containing a reference velocity field used to anchor
the unfolded velocities once the algorithm completes. Typically this
field is created by simulating the radial velocities from wind data
from an atmospheric sonding using
<a class="reference internal" href="util.html#pyart.util.simulated_vel_from_profile" title="pyart.util.simulated_vel_from_profile"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyart.util.simulated_vel_from_profile()</span></code></a>.</p>
</dd>
<dt><strong>interval_splits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of segments to split the nyquist interval into when finding
regions of similar velocity.  More splits creates a larger number of
initial regions which takes longer to process but may result in better
dealiasing.  The default value of 3 seems to be a good compromise
between performance and artifact free dealiasing.  This value
is not used if the interval_limits parameter is not None.</p>
</dd>
<dt><strong>interval_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array like or None, optional</span></dt>
<dd><p class="first last">Velocity limits used for finding regions of similar velocity.  Should
cover the entire nyquist interval.  None, the default value, will
split the Nyquist interval into interval_splits equal sized
intervals.</p>
</dd>
<dt><strong>skip_between_rays, skip_along_ray</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of filtered gates to skip over when joining regions,
gaps between region larger than this will not be connected.  Parameters
specify the maximum number of filtered gates between and along a ray.
Set these parameters to 0 to disable unfolding across filtered gates.</p>
</dd>
<dt><strong>centered</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to apply centering to each sweep after the dealiasing algorithm
so that the average number of unfolding is near 0.  False does not
apply centering which may results in individual sweeps under or over
folded by the nyquist interval.</p>
</dd>
<dt><strong>nyquist_velocity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array like or float, optional</span></dt>
<dd><p class="first last">Nyquist velocity in unit identical to those stored in the radar’s
velocity field, either for each sweep or a single value which will be
used for all sweeps.  None will attempt to determine this value from
the Radar object.</p>
</dd>
<dt><strong>check_nyquist_uniform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to check if the Nyquist velocities are uniform for all rays
within a sweep, False will skip this check.  This parameter is ignored
when the nyquist_velocity parameter is not None.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter, None or False, optional.</span></dt>
<dd><p class="first last">A GateFilter instance which specified which gates should be
ignored when performing de-aliasing.  A value of None created this
filter from the radar moments using any additional arguments by
passing them to <a class="reference internal" href="#pyart.correct.moment_based_gate_filter" title="pyart.correct.moment_based_gate_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">moment_based_gate_filter()</span></code></a>. False, the
default, disables filtering including all gates in the dealiasing.</p>
</dd>
<dt><strong>rays_wrap_around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or None, optional</span></dt>
<dd><p class="first last">True when the rays at the beginning of the sweep and end of the sweep
should be interpreted as connected when de-aliasing (PPI scans).
False if they edges should not be interpreted as connected (other scan
types).  None will determine the correct value from the radar
scan type.</p>
</dd>
<dt><strong>keep_original</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to retain the original Doppler velocity values at gates
where the dealiasing procedure fails or was not applied. False
does not replacement and these gates will be masked in the corrected
velocity field.</p>
</dd>
<dt><strong>set_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to set valid_min and valid_max elements in the returned
dictionary.  False will not set these dictionary elements.</p>
</dd>
<dt><strong>vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Field in radar to use as the Doppler velocities during dealiasing.
None will use the default field name from the Py-ART configuration
file.</p>
</dd>
<dt><strong>corr_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name to use for the dealiased Doppler velocity field metadata.  None
will use the default field name from the Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_vel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing dealiased Doppler velocities.  Dealiased
array is stored under the ‘data’ key.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.dealias_unwrap_phase">
<code class="descclassname">pyart.correct.</code><code class="descname">dealias_unwrap_phase</code><span class="sig-paren">(</span><em>radar</em>, <em>unwrap_unit='sweep'</em>, <em>nyquist_vel=None</em>, <em>check_nyquist_uniform=True</em>, <em>gatefilter=False</em>, <em>rays_wrap_around=None</em>, <em>keep_original=False</em>, <em>set_limits=True</em>, <em>vel_field=None</em>, <em>corr_vel_field=None</em>, <em>skip_checks=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/unwrap.html#dealias_unwrap_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.dealias_unwrap_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Dealias Doppler velocities using multi-dimensional phase unwrapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object containing Doppler velocities to dealias.</p>
</dd>
<dt><strong>unwrap_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘ray’, ‘sweep’, ‘volume’}, optional</span></dt>
<dd><p class="first last">Unit to unwrap independently.  ‘ray’ will unwrap each ray
individually, ‘sweep’ each sweep, and ‘volume’ will unwrap the entire
volume in a single pass.  ‘sweep’, the default, often gives superior
results when the lower sweeps of the radar volume are contaminated by
clutter. ‘ray’ does not use the gatefilter parameter and rays where
gates ared masked will result in poor dealiasing for that ray.</p>
</dd>
<dt><strong>nyquist_velocity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array like or float, optional</span></dt>
<dd><p class="first last">Nyquist velocity in unit identical to those stored in the radar’s
velocity field, either for each sweep or a single value which will be
used for all sweeps.  None will attempt to determine this value from
the Radar object.  The Nyquist velocity of the first sweep is used
for all dealiasing unless the unwrap_unit is ‘sweep’ when the
velocities of each sweep are used.</p>
</dd>
<dt><strong>check_nyquist_uniform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to check if the Nyquist velocities are uniform for all rays
within a sweep, False will skip this check.  This parameter is ignored
when the nyquist_velocity parameter is not None.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter, None or False, optional.</span></dt>
<dd><p class="first last">A GateFilter instance which specified which gates should be
ignored when performing de-aliasing.  A value of None created this
filter from the radar moments using any additional arguments by
passing them to <a class="reference internal" href="#pyart.correct.moment_based_gate_filter" title="pyart.correct.moment_based_gate_filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">moment_based_gate_filter()</span></code></a>.  False, the
default, disables filtering including all gates in the dealiasing.</p>
</dd>
<dt><strong>rays_wrap_around</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or None, optional</span></dt>
<dd><p class="first last">True when the rays at the beginning of the sweep and end of the sweep
should be interpreted as connected when de-aliasing (PPI scans).
False if they edges should not be interpreted as connected (other scan
types).  None will determine the correct value from the radar
scan type.</p>
</dd>
<dt><strong>keep_original</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to retain the original Doppler velocity values at gates
where the dealiasing procedure fails or was not applied. False
does not replacement and these gates will be masked in the corrected
velocity field.</p>
</dd>
<dt><strong>set_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to set valid_min and valid_max elements in the returned
dictionary.  False will not set these dictionary elements.</p>
</dd>
<dt><strong>vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Field in radar to use as the Doppler velocities during dealiasing.
None will use the default field name from the Py-ART configuration
file.</p>
</dd>
<dt><strong>corr_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name to use for the dealiased Doppler velocity field metadata.  None
will use the default field name from the Py-ART configuration file.</p>
</dd>
<dt><strong>skip_checks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True to skip checks verifing that an appropiate unwrap_unit is
selected, False retains these checked. Setting this parameter to True
is not recommended and is only offered as an option for extreme cases.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_vel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing dealiased Doppler velocities.  Dealiased
array is stored under the ‘data’ key.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="rc137adfe099a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Miguel Arevallilo Herraez, David R. Burton, Michael J. Lalor,
and Munther A. Gdeisat, “Fast two-dimensional phase-unwrapping
algorithm based on sorting by reliability following a noncontinuous
path”, Journal Applied Optics, Vol. 41, No. 35 (2002) 7437,</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="rc137adfe099a-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Abdul-Rahman, H., Gdeisat, M., Burton, D., &amp; Lalor, M., “Fast
three-dimensional phase-unwrapping algorithm based on sorting by
reliability following a non-continuous path. In W. Osten,
C. Gorecki, &amp; E. L. Novak (Eds.), Optical Metrology (2005) 32–40,
International Society for Optics and Photonics.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.despeckle_field">
<code class="descclassname">pyart.correct.</code><code class="descname">despeckle_field</code><span class="sig-paren">(</span><em>radar</em>, <em>field</em>, <em>label_dict=None</em>, <em>threshold=-100</em>, <em>size=10</em>, <em>gatefilter=None</em>, <em>delta=5.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/despeckle.html#despeckle_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.despeckle_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Despeckle a radar volume by identifying small objects in each scan and
masking them out. User can define which field to investigate, as well as
various thresholds to use on that field and any objects found within.
Requires scipy to be installed, and returns a GateFilter object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pyart.core.Radar object</span></dt>
<dd><p class="first last">Radar object to query.</p>
</dd>
<dt><strong>field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of field to investigate for speckles.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pyart.filters.GateFilter object</span></dt>
<dd><p class="first last">Py-ART GateFilter object that includes the despeckling mask</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>label_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict or None, optional</span></dt>
<dd><p class="first last">Dictionary that is produced by find_objects.
If None, find_objects will be called to produce it.</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or float, or 2-element tuple of ints or floats</span></dt>
<dd><p class="first last">Threshold values above (if single value) or between (if tuple)
for objects to be identified. Default value assumes reflectivity.</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of contiguous gates in an object, below which it is a speckle.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or pyart.filters.GateFilter object</span></dt>
<dd><p class="first last">Py-ART GateFilter object to which to add the despeckling mask. The
GateFilter object will be permanently modified with the new filtering.
If None, creates a new GateFilter.</p>
</dd>
<dt><strong>delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or float, optional</span></dt>
<dd><p class="first last">Size of allowable gap near PPI edges, in deg, to consider it full 360.
If gap is small, then PPI edges will be checked for matching objects.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.det_sys_phase_ray">
<code class="descclassname">pyart.correct.</code><code class="descname">det_sys_phase_ray</code><span class="sig-paren">(</span><em>radar</em>, <em>ind_rmin=10</em>, <em>ind_rmax=500</em>, <em>min_rcons=11</em>, <em>zmin=20.0</em>, <em>zmax=40.0</em>, <em>phidp_field=None</em>, <em>refl_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#det_sys_phase_ray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.det_sys_phase_ray" title="Permalink to this definition">¶</a></dt>
<dd><p>Public method
Alternative determination of the system phase.
Assumes that the valid gates of phidp are only precipitation.
A system phase value is found for each ray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object for which to determine the system phase.</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for continuous precipitation</p>
</dd>
<dt><strong>min_rcons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The minimum number of consecutive gates to consider it a rain cell.</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum and maximum reflectivity to consider the radar bin
suitable precipitation</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the differential
phase shift. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the reflectivity.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phidp0_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimate of the system phase at each ray and metadata</p>
</dd>
<dt><strong>first_gates_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The first gate where PhiDP is valid and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.est_rhohv_rain">
<code class="descclassname">pyart.correct.</code><code class="descname">est_rhohv_rain</code><span class="sig-paren">(</span><em>radar</em>, <em>ind_rmin=10</em>, <em>ind_rmax=500</em>, <em>zmin=20.0</em>, <em>zmax=40.0</em>, <em>thickness=700.0</em>, <em>doc=None</em>, <em>fzl=None</em>, <em>rhohv_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>refl_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#est_rhohv_rain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.est_rhohv_rain" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the quantiles of RhoHV in rain for each sweep</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for rain</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum and maximum reflectivity to consider the radar bin
suitable rain</p>
</dd>
<dt><strong>thickness</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Assumed thickness of the melting layer</p>
</dd>
<dt><strong>doc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number of gates at the end of each ray to to remove from the
calculation.</p>
</dd>
<dt><strong>fzl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Freezing layer, gates above this point are not included in the
correction.</p>
</dd>
<dt><strong>temp_field, iso0_field, rhohv_field, refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the temperature,
the height over the iso0, co-polar correlation and reflectivity
fields. A value of None will use the default field name as defined in
the Py-ART configuration file.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be either temperature
or height_over_iso0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rhohv_rain_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The estimated RhoHV in rain for each sweep and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.est_zdr_precip">
<code class="descclassname">pyart.correct.</code><code class="descname">est_zdr_precip</code><span class="sig-paren">(</span><em>radar</em>, <em>ind_rmin=10</em>, <em>ind_rmax=500</em>, <em>zmin=20.0</em>, <em>zmax=22.0</em>, <em>rhohvmin=0.97</em>, <em>phidpmax=10.0</em>, <em>elmax=None</em>, <em>thickness=700.0</em>, <em>doc=None</em>, <em>fzl=None</em>, <em>zdr_field=None</em>, <em>rhohv_field=None</em>, <em>phidp_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>refl_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#est_zdr_precip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.est_zdr_precip" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters out all undesired data to be able to estimate ZDR bias, either in
moderate rain or from vertically pointing scans</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for rain</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum and maximum reflectivity to consider the radar bin
suitable rain</p>
</dd>
<dt><strong>rhohvmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum RhoHV to consider the radar bin suitable rain</p>
</dd>
<dt><strong>phidpmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum PhiDP to consider the radar bin suitable rain</p>
</dd>
<dt><strong>elmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum elevation</p>
</dd>
<dt><strong>thickness</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Assumed thickness of the melting layer</p>
</dd>
<dt><strong>doc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number of gates at the end of each ray to to remove from the
calculation.</p>
</dd>
<dt><strong>fzl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Freezing layer, gates above this point are not included in the
correction.</p>
</dd>
<dt><strong>zdr_field, rhohv_field, refl_field, phidp_field, temp_field,</strong></dt>
<dd><p class="first last">iso0_field : str
Field names within the radar object which represent the differential
reflectivity, co-polar correlation, reflectivity, differential phase,
temperature and height relative to the iso0 fields. A value of None
will use the default field name as defined in the Py-ART configuration
file.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be either temperature,
height_over_iso0, fixed_fzl or None</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>zdr_prec_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The ZDR data complying with specifications and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.est_zdr_snow">
<code class="descclassname">pyart.correct.</code><code class="descname">est_zdr_snow</code><span class="sig-paren">(</span><em>radar, ind_rmin=10, ind_rmax=500, zmin=0.0, zmax=30.0, snrmin=10.0, snrmax=50.0, rhohvmin=0.97, kept_values=[2], phidpmax=10.0, kdpmax=None, tempmin=None, tempmax=None, elmax=None, zdr_field=None, rhohv_field=None, phidp_field=None, temp_field=None, snr_field=None, hydro_field=None, kdp_field=None, refl_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#est_zdr_snow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.est_zdr_snow" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters out all undesired data to be able to estimate ZDR bias in snow</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for snow</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum and maximum reflectivity to consider the radar bin
suitable snow</p>
</dd>
<dt><strong>snrmin, snrmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The minimum and maximum SNR to consider the radar bin suitable snow</p>
</dd>
<dt><strong>rhohvmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum RhoHV to consider the radar bin suitable snow</p>
</dd>
<dt><strong>kept_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">The hydrometeor classification values to keep</p>
</dd>
<dt><strong>phidpmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum PhiDP to consider the radar bin suitable snow</p>
</dd>
<dt><strong>kdpmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">Maximum KDP. If not none this is the maximum KDP value to consider
the radar bin suitable snow</p>
</dd>
<dt><strong>tempmin, tempmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">If not None, the minimum and maximum temperature to consider the
radar bin suitable snow</p>
</dd>
<dt><strong>elmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum elevation</p>
</dd>
<dt><strong>zdr_field, rhohv_field, refl_field, phidp_field, kdp_field, temp_field,</strong></dt>
<dd></dd>
<dt><strong>snr_field, hydro_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the differential
reflectivity, co-polar correlation, reflectivity, differential phase,
specific differnetial phase, signal to noise ratio, hydrometeor
classification and temperature fields. A value of None will use the
default field name as defined in the Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>zdr_snow_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The ZDR data complying with specifications and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.find_objects">
<code class="descclassname">pyart.correct.</code><code class="descname">find_objects</code><span class="sig-paren">(</span><em>radar</em>, <em>field</em>, <em>threshold</em>, <em>sweeps=None</em>, <em>smooth=None</em>, <em>gatefilter=None</em>, <em>delta=5.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/despeckle.html#find_objects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.find_objects" title="Permalink to this definition">¶</a></dt>
<dd><p>Find objects (i.e., contiguous gates) in one or more sweeps that match
thresholds. Filtering &amp; smoothing are available prior to labeling objects.
In addition, periodic boundaries are accounted for if they exist
(e.g., 360-deg PPIs). Requires scipy to be installed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pyart.core.Radar object</span></dt>
<dd><p class="first last">Radar object to query.</p>
</dd>
<dt><strong>field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of field to investigate for objects.</p>
</dd>
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or float, or 2-element tuple of ints or floats</span></dt>
<dd><p class="first last">Threshold values above (if single value) or between (if tuple)
for objects to be identified.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary that contains all the labeled objects. If this function is
performed on the full Radar object, then the dict is ready to be added
as a field.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>sweeps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or array of ints or None, optional</span></dt>
<dd><p class="first last">Sweep numbers to examine. If None, all sweeps are examined.</p>
</dd>
<dt><strong>smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None, optional</span></dt>
<dd><p class="first last">Number of gates included in a smoothing box filter along a ray.
If None, no smoothing is done prior to labeling objects.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or pyart.filters.GateFilter object</span></dt>
<dd><p class="first last">Py-ART GateFilter object to apply before labeling objects.
If None, no filtering will be performed. Note: Filtering always occurs
before smoothing.</p>
</dd>
<dt><strong>delta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or float, optional</span></dt>
<dd><p class="first last">Size of allowable gap near PPI edges, in deg, to consider it full 360.
If gap is small, then PPI edges will be checked for matching objects
along the periodic boundary.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.get_mask_fzl">
<code class="descclassname">pyart.correct.</code><code class="descname">get_mask_fzl</code><span class="sig-paren">(</span><em>radar</em>, <em>fzl=None</em>, <em>doc=None</em>, <em>min_temp=0.0</em>, <em>max_h_iso0=0.0</em>, <em>thickness=None</em>, <em>beamwidth=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/attenuation.html#get_mask_fzl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.get_mask_fzl" title="Permalink to this definition">¶</a></dt>
<dd><p>constructs a mask to mask data placed thickness m below data at min_temp
and beyond
Parameters
———-
radar : Radar</p>
<blockquote>
<div>the radar object</div></blockquote>
<dl class="docutils">
<dt>doc <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Number of gates at the end of each ray to to remove from the
calculation.</dd>
<dt>fzl <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Freezing layer, gates above this point are not included in the
correction.</dd>
<dt>min_temp <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>minimum temperature below which the data is mask in degrees</dd>
<dt>max_h_iso0 <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>maximum height relative to the iso0 below which the data is mask in
m</dd>
<dt>thickness <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>extent of the layer below the first gate where min_temp is reached
that is going to be masked</dd>
<dt>beamwidth <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>the radar antenna 3 dB beamwidth</dd>
<dt>temp_field, iso0_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Field names within the radar object which represent the temperature
or the height over iso0 fields. A value of None will use the default
field name as defined in the Py-ART configuration file. It is going
to be used only if available.</dd>
<dt>temp_ref <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>the field use as reference for temperature. Can be either temperature,
height_over_iso0 or fixed_fzl</dd>
</dl>
<dl class="docutils">
<dt>mask_fzl <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd>the values that should be masked</dd>
<dt>end_gate_arr <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd>the index of the last valid gate in the ray</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.get_sun_hits">
<code class="descclassname">pyart.correct.</code><code class="descname">get_sun_hits</code><span class="sig-paren">(</span><em>radar</em>, <em>delev_max=2.0</em>, <em>dazim_max=2.0</em>, <em>elmin=1.0</em>, <em>rmin=50000.0</em>, <em>hmin=10000.0</em>, <em>nbins_min=20</em>, <em>attg=None</em>, <em>max_std_pwr=1.0</em>, <em>max_std_zdr=1.5</em>, <em>pwrh_field=None</em>, <em>pwrv_field=None</em>, <em>zdr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#get_sun_hits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.get_sun_hits" title="Permalink to this definition">¶</a></dt>
<dd><p>get data from suspected sun hits</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>delev_max, dazim_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum difference in elevation and azimuth between sun position and
antenna pointing</p>
</dd>
<dt><strong>elmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">minimum radar elevation angle</p>
</dd>
<dt><strong>rmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">minimum range from which we can look for noise [m]</p>
</dd>
<dt><strong>hmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">minimum altitude from which we can look for noise [m]. The actual
range min will be the minimum between rmin and the range bin higher
than hmin.</p>
</dd>
<dt><strong>nbins_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of bins with valid data to consider a ray as
potentially sun hit</p>
</dd>
<dt><strong>attg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">gas attenuation coefficient (1-way)</p>
</dd>
<dt><strong>max_std_pwr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum standard deviation of the estimated sun power to consider the
sun signal valid [dB]</p>
</dd>
<dt><strong>max_std_zdr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum standard deviation of the estimated sun ZDR to consider the
sun signal valid [dB]</p>
</dd>
<dt><strong>pwrh_field, pwrv_field, zdr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">names of the signal power in dBm for the H and V polarizations and the
differential reflectivity</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sun_hits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">a dictionary containing information of the sun hits</p>
</dd>
<dt><strong>new_radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">radar object</span></dt>
<dd><p class="first last">radar object containing sweeps that contain sun hits</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.moment_based_gate_filter">
<code class="descclassname">pyart.correct.</code><code class="descname">moment_based_gate_filter</code><span class="sig-paren">(</span><em>radar</em>, <em>ncp_field=None</em>, <em>rhv_field=None</em>, <em>refl_field=None</em>, <em>min_ncp=0.5</em>, <em>min_rhv=None</em>, <em>min_refl=-20.0</em>, <em>max_refl=100.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/filters/gatefilter.html#moment_based_gate_filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.moment_based_gate_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a filter which removes undesired gates based on moments.</p>
<p>Creates a gate filter in which the following gates are excluded:</p>
<ul class="simple">
<li>Gates where the instrument is transitioning between sweeps.</li>
<li>Gates where the reflectivity is outside the interval min_refl, max_refl.</li>
<li>Gates where the normalized coherent power is below min_ncp.</li>
<li>Gates where the cross correlation ratio is below min_rhi.  Using the
default parameter this filtering is disabled.</li>
<li>Gates where any of the above three fields are masked or contain
invalid values (NaNs or infs).</li>
<li>If any of these three fields do not exist in the radar that fields filter
criteria is not applied.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object from which the gate filter will be built.</p>
</dd>
<dt><strong>refl_field, ncp_field, rhv_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Names of the radar fields which contain the reflectivity, normalized
coherent power (signal quality index) and cross correlation ratio
(RhoHV) from which the gate filter will be created using the above
criteria.  A value of None for any of these parameters will use the
default field name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>min_ncp, min_rhv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum values for the normalized coherence power and cross
correlation ratio.  Gates in these fields below these limits as well as
gates which are masked or contain invalid values will be excluded and
not used in calculation which use the filter.  A value of None will
disable filtering based upon the given field including removing
masked or gates with an invalid value.  To disable the thresholding
but retain the masked and invalid filter set the parameter to a value
below the lowest value in the field.</p>
</dd>
<dt><strong>min_refl, max_refl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum values for the reflectivity.  Gates outside
of this interval as well as gates which are masked or contain invalid
values will be excluded and not used in calculation which use this
filter. A value or None for one of these parameters will disable the
minimum or maximum filtering but retain the other.  A value of None
for both of these values will disable all filtering based upon the
reflectivity including removing masked or gates with an invalid value.
To disable the interval filtering but retain the masked and invalid
filter set the parameters to values above and below the lowest and
greatest values in the reflectivity field.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#pyart.correct.GateFilter" title="pyart.correct.GateFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">GateFilter</span></code></a></span></dt>
<dd><p class="first last">A gate filter based upon the described criteria.  This can be
used as a gatefilter parameter to various functions in pyart.correct.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.phase_proc_lp">
<code class="descclassname">pyart.correct.</code><code class="descname">phase_proc_lp</code><span class="sig-paren">(</span><em>radar</em>, <em>offset</em>, <em>debug=False</em>, <em>self_const=60000.0</em>, <em>low_z=10.0</em>, <em>high_z=53.0</em>, <em>min_phidp=0.01</em>, <em>min_ncp=0.5</em>, <em>min_rhv=0.8</em>, <em>fzl=4000.0</em>, <em>sys_phase=0.0</em>, <em>overide_sys_phase=False</em>, <em>nowrap=None</em>, <em>really_verbose=False</em>, <em>LP_solver='cylp'</em>, <em>refl_field=None</em>, <em>ncp_field=None</em>, <em>rhv_field=None</em>, <em>phidp_field=None</em>, <em>kdp_field=None</em>, <em>unf_field=None</em>, <em>window_len=35</em>, <em>proc=1</em>, <em>coef=0.914</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#phase_proc_lp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.phase_proc_lp" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase process using a LP method [1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Input radar.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Reflectivity offset in dBz.</p>
</dd>
<dt><strong>debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to print debugging information.</p>
</dd>
<dt><strong>self_const</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Self consistency factor.</p>
</dd>
<dt><strong>low_z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Low limit for reflectivity. Reflectivity below this value is set to
this limit.</p>
</dd>
<dt><strong>high_z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">High limit for reflectivity.  Reflectivity above this value is set to
this limit.</p>
</dd>
<dt><strong>min_phidp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum Phi differential phase.</p>
</dd>
<dt><strong>min_ncp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum normal coherent power.</p>
</dd>
<dt><strong>min_rhv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum copolar coefficient.</p>
</dd>
<dt><strong>fzl :</strong></dt>
<dd><p class="first last">Maximum altitude.</p>
</dd>
<dt><strong>sys_phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">System phase in degrees.</p>
</dd>
<dt><strong>overide_sys_phase: bool.</strong></dt>
<dd><p class="first last">True to use <cite>sys_phase</cite> as the system phase.  False will calculate a
value automatically.</p>
</dd>
<dt><strong>nowrap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None.</span></dt>
<dd><p class="first last">Gate number to begin phase unwrapping.  None will unwrap all phases.</p>
</dd>
<dt><strong>really_verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True to print LPX messaging. False to suppress.</p>
</dd>
<dt><strong>LP_solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘pyglpk’ or ‘cvxopt’, ‘cylp’, or ‘cylp_mp’</span></dt>
<dd><p class="first last">Module to use to solve LP problem.</p>
</dd>
<dt><strong>refl_field, ncp_field, rhv_field, phidp_field, kdp_field: str</strong></dt>
<dd><p class="first last">Name of field in radar which contains the horizonal reflectivity,
normal coherent power, copolar coefficient, differential phase shift,
and differential phase. A value of None for any of these parameters
will use the default field name as defined in the Py-ART configuration
file.</p>
</dd>
<dt><strong>unf_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of field which will be added to the radar object which will
contain the unfolded differential phase.  Metadata for this field
will be taken from the phidp_field.  A value of None will use
the default field name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>window_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Length of Sobel window applied to PhiDP field when prior to
calculating KDP.</p>
</dd>
<dt><strong>proc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of worker processes, only used when <cite>LP_solver</cite> is ‘cylp_mp’.</p>
</dd>
<dt><strong>coef</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Exponent linking Z to KDP in self consistency. kdp=(10**(0.1z))*coef</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reproc_phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing processed differential phase shifts.</p>
</dd>
<dt><strong>sob_kdp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing recalculated differential phases.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>[1] Giangrande, S.E., R. McGraw, and L. Lei. An Application of
Linear Programming to Polarimetric Radar Differential Phase Processing.
J. Atmos. and Oceanic Tech, 2013, 30, 1716.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.phase_proc_lp_gf">
<code class="descclassname">pyart.correct.</code><code class="descname">phase_proc_lp_gf</code><span class="sig-paren">(</span><em>radar</em>, <em>gatefilter=None</em>, <em>debug=False</em>, <em>self_const=60000.0</em>, <em>low_z=10.0</em>, <em>high_z=53.0</em>, <em>min_phidp=0.01</em>, <em>fzl=4000.0</em>, <em>system_phase=None</em>, <em>nowrap=None</em>, <em>really_verbose=False</em>, <em>LP_solver='cylp'</em>, <em>refl_field=None</em>, <em>phidp_field=None</em>, <em>kdp_field=None</em>, <em>unf_field=None</em>, <em>window_len=35</em>, <em>proc=1</em>, <em>coef=0.914</em>, <em>ncpts=None</em>, <em>first_gate_sysp=None</em>, <em>offset=0.0</em>, <em>doc=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#phase_proc_lp_gf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.phase_proc_lp_gf" title="Permalink to this definition">¶</a></dt>
<dd><p>Phase process using a LP method [1] using Py-ART’s Gatefilter.
Parameters
———-
radar : Radar</p>
<blockquote>
<div>Input radar.</div></blockquote>
<dl class="docutils">
<dt>gatefilter <span class="classifier-delimiter">:</span> <span class="classifier">Gatefilter, optional</span></dt>
<dd>Py-ART gatefilter object indicating where processing should be
carried out</dd>
<dt>debug <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd>True to print debugging information.</dd>
<dt>self_const <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd>Self consistency factor.</dd>
<dt>low_z <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Low limit for reflectivity. Reflectivity below this value is set to
this limit.</dd>
<dt>high_z <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>High limit for reflectivity.  Reflectivity above this value is set to
this limit.</dd>
<dt>fzl <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Maximum altitude.</dd>
<dt>system_phase <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>System phase in degrees.</dd>
<dt>nowrap <span class="classifier-delimiter">:</span> <span class="classifier">int or None.</span></dt>
<dd>Gate number to begin phase unwrapping.  None will unwrap all phases.</dd>
<dt>really_verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True to print LPX messaging. False to suppress.</dd>
<dt>LP_solver <span class="classifier-delimiter">:</span> <span class="classifier">‘pyglpk’ or ‘cvxopt’, ‘cylp’, or ‘cylp_mp’</span></dt>
<dd>Module to use to solve LP problem.</dd>
<dt>refl_field, ncp_field, rhv_field, phidp_field, kdp_field: str</dt>
<dd>Name of field in radar which contains the horizonal reflectivity,
normal coherent power, copolar coefficient, differential phase shift,
and differential phase. A value of None for any of these parameters
will use the default field name as defined in the Py-ART configuration
file.</dd>
<dt>unf_field <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Name of field which will be added to the radar object which will
contain the unfolded differential phase.  Metadata for this field
will be taken from the phidp_field.  A value of None will use
the default field name as defined in the Py-ART configuration file.</dd>
<dt>window_len <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Length of Sobel window applied to PhiDP field when prior to
calculating KDP.</dd>
<dt>proc <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of worker processes, only used when <cite>LP_solver</cite> is ‘cylp_mp’.</dd>
<dt>coef <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Exponent linking Z to KDP in self consistency. kdp=(10**(0.1z))*coef</dd>
<dt>ncpts <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Minimum number of points in a ray.  Regions within a ray smaller than
this or beginning before this gate number are excluded from unfolding.</dd>
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Reflectivity offset to add in dBz.</dd>
<dt>doc <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of gates to “doc” off the end of a ray</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reproc_phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing processed differential phase shifts.</p>
</dd>
<dt><strong>sob_kdp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing recalculated differential phases.</p>
</dd>
<dt><strong>References</strong></dt>
<dd></dd>
<dt><strong>———-</strong></dt>
<dd></dd>
<dt><strong>[1] Giangrande, S.E., R. McGraw, and L. Lei. An Application of</strong></dt>
<dd></dd>
<dt><strong>Linear Programming to Polarimetric Radar Differential Phase Processing.</strong></dt>
<dd></dd>
<dt><strong>J. Atmos. and Oceanic Tech, 2013, 30, 1716.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.ptoa_to_sf">
<code class="descclassname">pyart.correct.</code><code class="descname">ptoa_to_sf</code><span class="sig-paren">(</span><em>ptoa</em>, <em>pulse_width</em>, <em>wavelen</em>, <em>antenna_gain</em>, <em>coeff_band=1.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/sunlib.html#ptoa_to_sf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.ptoa_to_sf" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the sun power at the top of the atmosphere (in dBm) into solar
flux.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ptoa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">sun power at the top of the amosphere. It already takes into account
the correction for antenna polarization</p>
</dd>
<dt><strong>pulse_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">pulse width [s]</p>
</dd>
<dt><strong>wavelen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar wavelength [m]</p>
</dd>
<dt><strong>antenna_gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the antenna gain [dB]</p>
</dd>
<dt><strong>coeff_band</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">multiplicative coefficient applied to the inverse of the pulse width
to get the effective bandwidth</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>s0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">solar flux [10e-22 W/(m2 Hz)]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Altube P., J. Bech, O. Argemi, T. Rigo, 2015: Quality Control of Antenna
Alignment and Receiver Calibration Using the Sun: Adaptation to Midrange
Weather Radar Observations at Low Elevation Angles</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.scanning_losses">
<code class="descclassname">pyart.correct.</code><code class="descname">scanning_losses</code><span class="sig-paren">(</span><em>angle_step</em>, <em>beamwidth</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/sunlib.html#scanning_losses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.scanning_losses" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the antenna beam width and the integration angle, compute the
losses due to the fact that the sun is not a point target and the antenna
is scanning</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>angle_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">integration angle [deg]</p>
</dd>
<dt><strong>beamwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">3 dB-beamwidth [deg]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>la</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The losses due to the scanning of the antenna [dB positive]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Altube P., J. Bech, O. Argemi, T. Rigo, 2015: Quality Control of Antenna
Alignment and Receiver Calibration Using the Sun: Adaptation to Midrange
Weather Radar Observations at Low Elevation Angles</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.selfconsistency_bias">
<code class="descclassname">pyart.correct.</code><code class="descname">selfconsistency_bias</code><span class="sig-paren">(</span><em>radar</em>, <em>zdr_kdpzh_dict</em>, <em>min_rhohv=0.92</em>, <em>max_phidp=20.0</em>, <em>smooth_wind_len=5</em>, <em>doc=None</em>, <em>fzl=None</em>, <em>thickness=700.0</em>, <em>min_rcons=20</em>, <em>dphidp_min=2</em>, <em>dphidp_max=16</em>, <em>refl_field=None</em>, <em>phidp_field=None</em>, <em>zdr_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>rhohv_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#selfconsistency_bias"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.selfconsistency_bias" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates reflectivity bias at each ray using the self-consistency
algorithm by Gourley</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>zdr_kdpzh_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dictionary containing a look up table relating ZDR with KDP/Zh for
different elevations</p>
</dd>
<dt><strong>min_rhohv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">minimum RhoHV value to consider the data valid</p>
</dd>
<dt><strong>max_phidp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum PhiDP value to consider the data valid</p>
</dd>
<dt><strong>smooth_wind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">length of the smoothing window</p>
</dd>
<dt><strong>doc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number of gates at the end of each ray to to remove from the
calculation.</p>
</dd>
<dt><strong>fzl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Freezing layer, gates above this point are not included in the
correction.</p>
</dd>
<dt><strong>min_rcons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">minimum number of consecutive gates to consider a valid segment of
PhiDP</p>
</dd>
<dt><strong>dphidp_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">minimum differential phase shift in a segment</p>
</dd>
<dt><strong>dphidp_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum differential phase shift in a segment</p>
</dd>
<dt><strong>refl_field, phidp_field, zdr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the reflectivity,
differential phase and differential reflectivity fields. A value of
None will use the default field name as defined in the Py-ART
configuration file.</p>
</dd>
<dt><strong>temp_field, iso0_field, rhohv_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the temperature,
the height relative to the iso0 and the co-polar correlation fields. A
value of None will use the default field name as defined in the Py-ART
configuration file. They are going to be used only if available.</p>
</dd>
<dt><strong>kdpsim_field, phidpsim_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names which represent the estimated specific differential phase
and differential phase. A value of None will use the default
field name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be either temperature,
height_over_iso0 or fixed_fzl</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>refl_bias_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">the bias at each ray field and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.selfconsistency_kdp_phidp">
<code class="descclassname">pyart.correct.</code><code class="descname">selfconsistency_kdp_phidp</code><span class="sig-paren">(</span><em>radar</em>, <em>zdr_kdpzh_dict</em>, <em>min_rhohv=0.92</em>, <em>max_phidp=20.0</em>, <em>smooth_wind_len=5</em>, <em>doc=None</em>, <em>fzl=None</em>, <em>thickness=700.0</em>, <em>refl_field=None</em>, <em>phidp_field=None</em>, <em>zdr_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>rhohv_field=None</em>, <em>kdpsim_field=None</em>, <em>phidpsim_field=None</em>, <em>temp_ref='temperature'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#selfconsistency_kdp_phidp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.selfconsistency_kdp_phidp" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates KDP and PhiDP in rain from  Zh and ZDR using a selfconsistency
relation between ZDR, Zh and KDP. Private method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>zdr_kdpzh_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dictionary containing a look up table relating ZDR with KDP/Zh for
different elevations</p>
</dd>
<dt><strong>min_rhohv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">minimum RhoHV value to consider the data valid</p>
</dd>
<dt><strong>max_phidp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum PhiDP value to consider the data valid</p>
</dd>
<dt><strong>smooth_wind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">length of the smoothing window</p>
</dd>
<dt><strong>doc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number of gates at the end of each ray to to remove from the
calculation.</p>
</dd>
<dt><strong>fzl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Freezing layer, gates above this point are not included in the
correction.</p>
</dd>
<dt><strong>thickness</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">assumed melting layer thickness [m]</p>
</dd>
<dt><strong>refl_field, phidp_field, zdr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the reflectivity,
differential phase and differential reflectivity fields. A value of
None will use the default field name as defined in the Py-ART
configuration file.</p>
</dd>
<dt><strong>temp_field, iso0_field, rhohv_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names within the radar object which represent the temperature,
the height relative to the iso0 and the co-polar correlation fields. A
value of None will use the default field name as defined in the Py-ART
configuration file. They are going to be used only if available.</p>
</dd>
<dt><strong>kdpsim_field, phidpsim_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field names which represent the estimated specific differential phase
and differential phase. A value of None will use the default
field name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be either temperature,
height_over_iso0 or fixed_fzl</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kdp_sim_dict, phidp_sim_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">the KDP and PhiDP estimated fields and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.smooth_masked">
<code class="descclassname">pyart.correct.</code><code class="descname">smooth_masked</code><span class="sig-paren">(</span><em>raw_data</em>, <em>wind_len=11</em>, <em>min_valid=6</em>, <em>wind_type='median'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#smooth_masked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.smooth_masked" title="Permalink to this definition">¶</a></dt>
<dd><p>smoothes the data using a rolling window.
data with less than n valid points is masked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>raw_data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float masked array</span></dt>
<dd><p class="first last">The data to smooth.</p>
</dd>
<dt><strong>window_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Length of the moving window</p>
</dd>
<dt><strong>min_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum number of valid points for the smoothing to be valid</p>
</dd>
<dt><strong>wind_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">type of window. Can be median or mean</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data_smooth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float masked array</span></dt>
<dd><p class="first last">smoothed data</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.smooth_phidp_double_window">
<code class="descclassname">pyart.correct.</code><code class="descname">smooth_phidp_double_window</code><span class="sig-paren">(</span><em>radar</em>, <em>ind_rmin=10</em>, <em>ind_rmax=500</em>, <em>min_rcons=11</em>, <em>zmin=20.0</em>, <em>zmax=40</em>, <em>swind_len=11</em>, <em>smin_valid=6</em>, <em>lwind_len=31</em>, <em>lmin_valid=16</em>, <em>zthr=40.0</em>, <em>psidp_field=None</em>, <em>refl_field=None</em>, <em>phidp_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#smooth_phidp_double_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.smooth_phidp_double_window" title="Permalink to this definition">¶</a></dt>
<dd><p>correction of the system offset and smoothing using two window</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object for which to determine the system phase.</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for continuous precipitation</p>
</dd>
<dt><strong>min_rcons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The minimum number of consecutive gates to consider it a rain cell.</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum reflectivity to consider it a rain cell</p>
</dd>
<dt><strong>swind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Length of the short moving window used to smooth</p>
</dd>
<dt><strong>smin_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid bins to consider the short window smooth data
valid</p>
</dd>
<dt><strong>lwind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Length of the long moving window used to smooth</p>
</dd>
<dt><strong>lmin_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid bins to consider the long window smooth data
valid</p>
</dd>
<dt><strong>zthr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">reflectivity value above which the short window is used</p>
</dd>
<dt><strong>psidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the differential
phase shift. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the reflectivity.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the corrected
differential phase shift. A value of None will use the default field
name as defined in the Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phidp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The corrected phidp field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.smooth_phidp_single_window">
<code class="descclassname">pyart.correct.</code><code class="descname">smooth_phidp_single_window</code><span class="sig-paren">(</span><em>radar</em>, <em>ind_rmin=10</em>, <em>ind_rmax=500</em>, <em>min_rcons=11</em>, <em>zmin=20.0</em>, <em>zmax=40</em>, <em>wind_len=11</em>, <em>min_valid=6</em>, <em>psidp_field=None</em>, <em>refl_field=None</em>, <em>phidp_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/phase_proc.html#smooth_phidp_single_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.smooth_phidp_single_window" title="Permalink to this definition">¶</a></dt>
<dd><p>correction of the system offset and smoothing using one window</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object for which to determine the system phase.</p>
</dd>
<dt><strong>ind_rmin, ind_rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Min and max range index where to look for continuous precipitation</p>
</dd>
<dt><strong>min_rcons</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The minimum number of consecutive gates to consider it a rain cell.</p>
</dd>
<dt><strong>zmin, zmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum reflectivity to consider it a rain cell</p>
</dd>
<dt><strong>wind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Length of the moving window used to smooth</p>
</dd>
<dt><strong>min_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid bins to consider the smooth data valid</p>
</dd>
<dt><strong>psidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the differential
phase shift. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the reflectivity.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the corrected
differential phase shift. A value of None will use the default field
name as defined in the Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phidp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">The corrected phidp field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.solar_flux_lookup">
<code class="descclassname">pyart.correct.</code><code class="descname">solar_flux_lookup</code><span class="sig-paren">(</span><em>solar_flux</em>, <em>wavelen</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/sunlib.html#solar_flux_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.solar_flux_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the observed solar flux at 10.7 cm wavelength, returns the solar
flux at the given radar wavelength</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>solar_flux</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">the solar fluxes measured at 10.7 cm wavelength [10e-22 W/(m2 Hz)]</p>
</dd>
<dt><strong>wavelen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar wavelength [m]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>s0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the radar flux at the radar wavelength [10e-22 W/(m2 Hz)]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Altube P., J. Bech, O. Argemi, T. Rigo, 2015: Quality Control of Antenna
Alignment and Receiver Calibration Using the Sun: Adaptation to Midrange
Weather Radar Observations at Low Elevation Angles</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.sun_power">
<code class="descclassname">pyart.correct.</code><code class="descname">sun_power</code><span class="sig-paren">(</span><em>solar_flux</em>, <em>pulse_width</em>, <em>wavelen</em>, <em>antenna_gain</em>, <em>angle_step</em>, <em>beamwidth</em>, <em>coeff_band=1.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/sunlib.html#sun_power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.sun_power" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the theoretical sun power detected at the antenna [dBm] as it
would be without atmospheric attenuation (sun power at top of the
atmosphere) for a given solar flux and radar characteristics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>solar_flux</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">the solar fluxes measured at 10.7 cm wavelength [10e-22 W/(m2 Hz)]</p>
</dd>
<dt><strong>pulse_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">pulse width [s]</p>
</dd>
<dt><strong>wavelen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar wavelength [m]</p>
</dd>
<dt><strong>antenna_gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">the antenna gain [dB]</p>
</dd>
<dt><strong>angle_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">integration angle [deg]</p>
</dd>
<dt><strong>beamwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">3 dB-beamwidth [deg]</p>
</dd>
<dt><strong>coeff_band</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">multiplicative coefficient applied to the inverse of the pulse width
to get the effective bandwidth</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pwr_det</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">the detected power</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Altube P., J. Bech, O. Argemi, T. Rigo, 2015: Quality Control of Antenna
Alignment and Receiver Calibration Using the Sun: Adaptation to Midrange
Weather Radar Observations at Low Elevation Angles</p>
</dd></dl>

<dl class="function">
<dt id="pyart.correct.sun_retrieval">
<code class="descclassname">pyart.correct.</code><code class="descname">sun_retrieval</code><span class="sig-paren">(</span><em>az_rad</em>, <em>az_sun</em>, <em>el_rad</em>, <em>el_sun</em>, <em>sun_hit</em>, <em>sun_hit_std</em>, <em>az_width_co=None</em>, <em>el_width_co=None</em>, <em>az_width_cross=None</em>, <em>el_width_cross=None</em>, <em>is_zdr=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/correct/bias_and_noise.html#sun_retrieval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.correct.sun_retrieval" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates sun parameters from sun hits</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>az_rad, az_sun, el_rad, el_sun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">azimuth and elevation values of the sun and the radar</p>
</dd>
<dt><strong>sun_hit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">sun hit value. Either power in dBm or ZDR in dB</p>
</dd>
<dt><strong>sun_hit_std</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">standard deviation of the sun hit value in dB</p>
</dd>
<dt><strong>az_width_co, el_width_co, az_width_cross, el_width_cross</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">azimuth and elevation antenna width for each channel</p>
</dd>
<dt><strong>is_zdr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">boolean to signal that is ZDR data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>val, val_std</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">retrieved value and its standard deviation</p>
</dd>
<dt><strong>az_bias, el_bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">retrieved azimuth and elevation antenna bias respect to the sun
position</p>
</dd>
<dt><strong>az_width, el_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">retrieved azimuth and elevation antenna widths</p>
</dd>
<dt><strong>nhits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of sun hits used in the retrieval</p>
</dd>
<dt><strong>par</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array</span></dt>
<dd><p class="first last">and array with the 5 parameters of the Gaussian fit</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyart-mch 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, meteoswiss-mdr.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
  </body>
</html>