
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Radar Retrievals (pyart.retrieve) &#8212; pyart-mch 0.1.0 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyart-mch 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Radar Retrievals (<code class="docutils literal notranslate"><span class="pre">pyart.retrieve</span></code>)</a><ul>
<li><a class="reference internal" href="#radar-retrievals">Radar retrievals</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/retrieve.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <hr class="docutils" />
<span class="target" id="module-pyart.retrieve"></span><div class="section" id="radar-retrievals-pyart-retrieve">
<h1>Radar Retrievals (<a class="reference internal" href="#module-pyart.retrieve" title="pyart.retrieve"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyart.retrieve</span></code></a>)<a class="headerlink" href="#radar-retrievals-pyart-retrieve" title="Permalink to this headline">¶</a></h1>
<p>Radar retrievals.</p>
<div class="section" id="radar-retrievals">
<h2>Radar retrievals<a class="headerlink" href="#radar-retrievals" title="Permalink to this headline">¶</a></h2>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.kdp_maesaka" title="pyart.retrieve.kdp_maesaka"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdp_maesaka</span></code></a>(radar[,&nbsp;gatefilter,&nbsp;method,&nbsp;…])</td>
<td>Compute the specific differential phase (KDP) from corrected (e.g., unfolded) total differential phase data based on the variational method outlined in Maesaka et al.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.kdp_schneebeli" title="pyart.retrieve.kdp_schneebeli"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdp_schneebeli</span></code></a>(radar[,&nbsp;gatefilter,&nbsp;…])</td>
<td>Estimates Kdp with the Kalman filter method by Schneebeli and al.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.kdp_vulpiani" title="pyart.retrieve.kdp_vulpiani"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdp_vulpiani</span></code></a>(radar[,&nbsp;gatefilter,&nbsp;…])</td>
<td>Estimates Kdp with the Vulpiani method for a 2D array of psidp measurements with the first dimension being the distance from radar and the second dimension being the angles (azimuths for PPI, elev for RHI).The input psidp is assumed to be pre-filtered (for ex.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.kdp_leastsquare_single_window" title="pyart.retrieve.kdp_leastsquare_single_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdp_leastsquare_single_window</span></code></a>(radar[,&nbsp;…])</td>
<td>Compute the specific differential phase (KDP) from differential phase data using a piecewise least square method.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.kdp_leastsquare_double_window" title="pyart.retrieve.kdp_leastsquare_double_window"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kdp_leastsquare_double_window</span></code></a>(radar[,&nbsp;…])</td>
<td>Compute the specific differential phase (KDP) from differential phase data using a piecewise least square method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.calculate_snr_from_reflectivity" title="pyart.retrieve.calculate_snr_from_reflectivity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_snr_from_reflectivity</span></code></a>(radar[,&nbsp;…])</td>
<td>Calculate the signal to noise ratio, in dB, from the reflectivity field.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.calculate_velocity_texture" title="pyart.retrieve.calculate_velocity_texture"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate_velocity_texture</span></code></a>(radar[,&nbsp;…])</td>
<td>Derive the texture of the velocity field</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_snr" title="pyart.retrieve.compute_snr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_snr</span></code></a>(radar[,&nbsp;refl_field,&nbsp;…])</td>
<td>Computes SNR from a reflectivity field and the noise in dBZ.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_l" title="pyart.retrieve.compute_l"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_l</span></code></a>(radar[,&nbsp;rhohv_field,&nbsp;l_field])</td>
<td>Computes Rhohv in logarithmic scale according to L=-log10(1-RhoHV)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_cdr" title="pyart.retrieve.compute_cdr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cdr</span></code></a>(radar[,&nbsp;rhohv_field,&nbsp;zdr_field,&nbsp;…])</td>
<td>Computes the Circular Depolarization Ratio</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_noisedBZ" title="pyart.retrieve.compute_noisedBZ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_noisedBZ</span></code></a>(nrays,&nbsp;noisedBZ_val,&nbsp;rng,&nbsp;…)</td>
<td>Computes noise in dBZ from reference noise value.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_signal_power" title="pyart.retrieve.compute_signal_power"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_signal_power</span></code></a>(radar[,&nbsp;lmf,&nbsp;attg,&nbsp;…])</td>
<td>Computes received signal power OUTSIDE THE RADOME in dBm from a reflectivity field.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_rcs" title="pyart.retrieve.compute_rcs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_rcs</span></code></a>(radar[,&nbsp;kw2,&nbsp;pulse_width,&nbsp;…])</td>
<td>Computes the radar cross-section (assuming a point target) from radar reflectivity.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_rcs_from_pr" title="pyart.retrieve.compute_rcs_from_pr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_rcs_from_pr</span></code></a>(radar[,&nbsp;lmf,&nbsp;attg,&nbsp;…])</td>
<td>Computes the radar cross-section (assuming a point target) from radar reflectivity by first computing the received power and then the RCS from it.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_vol_refl" title="pyart.retrieve.compute_vol_refl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_vol_refl</span></code></a>(radar[,&nbsp;kw,&nbsp;freq,&nbsp;…])</td>
<td>Computes the volumetric reflectivity from the effective reflectivity factor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_bird_density" title="pyart.retrieve.compute_bird_density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_bird_density</span></code></a>(radar[,&nbsp;sigma_bird,&nbsp;…])</td>
<td>Computes the bird density from the volumetric reflectivity</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.fetch_radar_time_profile" title="pyart.retrieve.fetch_radar_time_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fetch_radar_time_profile</span></code></a>(sonde_dset,&nbsp;radar)</td>
<td>Extract the correct profile from a interpolated sonde.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.map_profile_to_gates" title="pyart.retrieve.map_profile_to_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_profile_to_gates</span></code></a>(profile,&nbsp;heights,&nbsp;radar)</td>
<td>Given a profile of a variable map it to the gates of radar assuming 4/3Re.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.steiner_conv_strat" title="pyart.retrieve.steiner_conv_strat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">steiner_conv_strat</span></code></a>(grid[,&nbsp;dx,&nbsp;dy,&nbsp;intense,&nbsp;…])</td>
<td>Partition reflectivity into convective-stratiform using the Steiner et al.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.hydroclass_semisupervised" title="pyart.retrieve.hydroclass_semisupervised"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hydroclass_semisupervised</span></code></a>(radar[,&nbsp;…])</td>
<td>Classifies precipitation echoes following the approach by Besic et al (2016)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.get_freq_band" title="pyart.retrieve.get_freq_band"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_freq_band</span></code></a>(freq)</td>
<td>returns the frequency band name (S, C, X, …)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">texture_of_complex_phase</span></code>(radar[,&nbsp;…])</td>
<td>Calculate the texture of the differential phase field.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.grid_displacement_pc" title="pyart.retrieve.grid_displacement_pc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_displacement_pc</span></code></a>(grid1,&nbsp;grid2,&nbsp;field,&nbsp;level)</td>
<td>Calculate the grid displacement using phase correlation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.grid_shift" title="pyart.retrieve.grid_shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_shift</span></code></a>(grid,&nbsp;advection[,&nbsp;trim_edges,&nbsp;…])</td>
<td>Shift a grid by a certain number of pixels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_zpoly" title="pyart.retrieve.est_rain_rate_zpoly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_zpoly</span></code></a>(radar[,&nbsp;refl_field,&nbsp;…])</td>
<td>Estimates rainfall rate from reflectivity using a polynomial Z-R relation developed at McGill University</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_z" title="pyart.retrieve.est_rain_rate_z"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_z</span></code></a>(radar[,&nbsp;alpha,&nbsp;beta,&nbsp;…])</td>
<td>Estimates rainfall rate from reflectivity using a power law</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_kdp" title="pyart.retrieve.est_rain_rate_kdp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_kdp</span></code></a>(radar[,&nbsp;alpha,&nbsp;beta,&nbsp;…])</td>
<td>Estimates rainfall rate from kdp using alpha power law</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_a" title="pyart.retrieve.est_rain_rate_a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_a</span></code></a>(radar[,&nbsp;alpha,&nbsp;beta,&nbsp;…])</td>
<td>Estimates rainfall rate from specific attenuation using alpha power law</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_zkdp" title="pyart.retrieve.est_rain_rate_zkdp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_zkdp</span></code></a>(radar[,&nbsp;alphaz,&nbsp;betaz,&nbsp;…])</td>
<td>Estimates rainfall rate from a blending of power law r-kdp and r-z relations.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_za" title="pyart.retrieve.est_rain_rate_za"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_za</span></code></a>(radar[,&nbsp;alphaz,&nbsp;betaz,&nbsp;…])</td>
<td>Estimates rainfall rate from a blending of power law r-alpha and r-z relations.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.est_rain_rate_hydro" title="pyart.retrieve.est_rain_rate_hydro"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_rain_rate_hydro</span></code></a>(radar[,&nbsp;alphazr,&nbsp;…])</td>
<td>Estimates rainfall rate using different relations between R and the polarimetric variables depending on the hydrometeor type</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.est_wind_vel" title="pyart.retrieve.est_wind_vel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_wind_vel</span></code></a>(radar[,&nbsp;vert_proj,&nbsp;vel_field,&nbsp;…])</td>
<td>Estimates wind velocity.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.est_vertical_windshear" title="pyart.retrieve.est_vertical_windshear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_vertical_windshear</span></code></a>(radar[,&nbsp;az_tol,&nbsp;…])</td>
<td>Estimates wind shear.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.atmospheric_gas_att" title="pyart.retrieve.atmospheric_gas_att"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atmospheric_gas_att</span></code></a>(freq,&nbsp;elev,&nbsp;rng)</td>
<td>Computes the one-way atmospheric gas attenuation [dB] according to the empirical formula in Doviak and Zrnic (1993) pp 44.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.get_coeff_attg" title="pyart.retrieve.get_coeff_attg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coeff_attg</span></code></a>(freq)</td>
<td>get the 1-way gas attenuation for a particular frequency</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.est_wind_profile" title="pyart.retrieve.est_wind_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">est_wind_profile</span></code></a>(radar[,&nbsp;npoints_min,&nbsp;…])</td>
<td>Estimates the vertical wind profile using VAD techniques</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.detect_ml" title="pyart.retrieve.detect_ml"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detect_ml</span></code></a>(radar[,&nbsp;gatefilter,&nbsp;fill_value,&nbsp;…])</td>
<td>Detects the melting layer (ML) using the reflectivity and copolar correlation coefficient.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.melting_layer_giangrande" title="pyart.retrieve.melting_layer_giangrande"><code class="xref py py-obj docutils literal notranslate"><span class="pre">melting_layer_giangrande</span></code></a>(radar[,&nbsp;nVol,&nbsp;…])</td>
<td>Detects the melting layer following the approach by Giangrande et al (2008)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.melting_layer_hydroclass" title="pyart.retrieve.melting_layer_hydroclass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">melting_layer_hydroclass</span></code></a>(radar[,&nbsp;…])</td>
<td>Using the results of the hydrometeor classification by Besic et al.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">_get_res_vol_sides</span></code>(radar)</td>
<td>Computes the height of the lower left and upper right points of the range resolution volume.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.velocity_azimuth_display" title="pyart.retrieve.velocity_azimuth_display"><code class="xref py py-obj docutils literal notranslate"><span class="pre">velocity_azimuth_display</span></code></a>(radar[,&nbsp;vel_field,&nbsp;…])</td>
<td>Velocity azimuth display.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.quasi_vertical_profile" title="pyart.retrieve.quasi_vertical_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quasi_vertical_profile</span></code></a>(radar[,&nbsp;…])</td>
<td>Quasi Vertical Profile.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_qvp" title="pyart.retrieve.compute_qvp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_qvp</span></code></a>(radar,&nbsp;field_names[,&nbsp;ref_time,&nbsp;…])</td>
<td>Computes quasi vertical profiles.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_rqvp" title="pyart.retrieve.compute_rqvp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_rqvp</span></code></a>(radar,&nbsp;field_names[,&nbsp;ref_time,&nbsp;…])</td>
<td>Computes range-defined quasi vertical profiles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_evp" title="pyart.retrieve.compute_evp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_evp</span></code></a>(radar,&nbsp;field_names,&nbsp;lon,&nbsp;lat[,&nbsp;…])</td>
<td>Computes enhanced vertical profiles.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.retrieve.compute_svp" title="pyart.retrieve.compute_svp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_svp</span></code></a>(radar,&nbsp;field_names,&nbsp;lon,&nbsp;lat,&nbsp;angle)</td>
<td>Computes slanted vertical profiles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.retrieve.compute_vp" title="pyart.retrieve.compute_vp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_vp</span></code></a>(radar,&nbsp;field_names,&nbsp;lon,&nbsp;lat[,&nbsp;…])</td>
<td>Computes vertical profiles.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="pyart.retrieve.atmospheric_gas_att">
<code class="descclassname">pyart.retrieve.</code><code class="descname">atmospheric_gas_att</code><span class="sig-paren">(</span><em>freq</em>, <em>elev</em>, <em>rng</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#atmospheric_gas_att"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.atmospheric_gas_att" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the one-way atmospheric gas attenuation [dB] according to the
empirical formula in Doviak and Zrnic (1993) pp 44.
This formula is valid for elev &lt; 10 deg and rng &lt; 200 km so values above
these will be saturated to 10 deg and 200 km respectively</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar frequency [Hz]</p>
</dd>
<dt><strong>elev</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of floats</span></dt>
<dd><p class="first last">elevation angle [deg]</p>
</dd>
<dt><strong>rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of floats. If array must have the same size as elev</span></dt>
<dd><p class="first last">range [km]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>latm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of floats</span></dt>
<dd><p class="first last">1-way gas attenuation [dB]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.calculate_snr_from_reflectivity">
<code class="descclassname">pyart.retrieve.</code><code class="descname">calculate_snr_from_reflectivity</code><span class="sig-paren">(</span><em>radar</em>, <em>refl_field=None</em>, <em>snr_field=None</em>, <em>toa=25000.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#calculate_snr_from_reflectivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.calculate_snr_from_reflectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the signal to noise ratio, in dB, from the reflectivity field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object from which to retrieve reflectivity field.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of field in radar which contains the reflectivity.
None will use the default field name in the Py-ART configuration file.</p>
</dd>
<dt><strong>snr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name to use for snr metadata.
None will use the default field name in the Py-ART configuration file.</p>
</dd>
<dt><strong>toa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Height above which to take noise floor measurements, in meters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>snr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">field dictionary</span></dt>
<dd><p class="first last">Field dictionary containing the signal to noise ratio.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.calculate_velocity_texture">
<code class="descclassname">pyart.retrieve.</code><code class="descname">calculate_velocity_texture</code><span class="sig-paren">(</span><em>radar</em>, <em>vel_field=None</em>, <em>wind_size=4</em>, <em>nyq=None</em>, <em>check_nyq_uniform=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#calculate_velocity_texture"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.calculate_velocity_texture" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive the texture of the velocity field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar: Radar</strong></dt>
<dd><p class="first last">Radar object from which velocity texture field will be made.</p>
</dd>
<dt><strong>vel_field_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the velocity field. A value of None will force Py-ART to
automatically determine the name of the velocity field.</p>
</dd>
<dt><strong>wind_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The size of the window to calculate texture from. The window is
defined to be a square of size wind_size by wind_size.</p>
</dd>
<dt><strong>nyq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The nyquist velocity of the radar. A value of None will force Py-ART
to try and determine this automatically.</p>
</dd>
<dt><strong>check_nyquist_uniform</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to check if the Nyquist velocities are uniform for all rays
within a sweep, False will skip this check. This parameter is ignored
when the nyq parameter is not None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vel_dict: dict</strong></dt>
<dd><p class="first last">A dictionary containing the field entries for the radial velocity
texture.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_bird_density">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_bird_density</code><span class="sig-paren">(</span><em>radar</em>, <em>sigma_bird=11</em>, <em>vol_refl_field=None</em>, <em>bird_density_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_bird_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_bird_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bird density from the volumetric reflectivity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>sigma_bird</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Estimated bird radar cross-section</p>
</dd>
<dt><strong>vol_refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the volumetric reflectivity used for the calculations</p>
</dd>
<dt><strong>bird_density_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the bird density field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bird_density_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">bird density data and metadata [birds/km^3]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_cdr">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_cdr</code><span class="sig-paren">(</span><em>radar</em>, <em>rhohv_field=None</em>, <em>zdr_field=None</em>, <em>cdr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_cdr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_cdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Circular Depolarization Ratio</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>rhohv_field, zdr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the input RhoHV and ZDR fields</p>
</dd>
<dt><strong>cdr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the CDR field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cdr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">CDR field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_evp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_evp</code><span class="sig-paren">(</span><em>radar</em>, <em>field_names</em>, <em>lon</em>, <em>lat</em>, <em>ref_time=None</em>, <em>latlon_tol=0.0005</em>, <em>delta_rng=15000.0</em>, <em>delta_azi=10</em>, <em>hmax=10000.0</em>, <em>hres=250.0</em>, <em>avg_type='mean'</em>, <em>nvalid_min=1</em>, <em>interp_kind='none'</em>, <em>qvp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qvp.html#compute_evp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_evp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes enhanced vertical profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>field_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of field names to add to the QVP</p>
</dd>
<dt><strong>lat, lon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">latitude and longitude of the point of interest [deg]</p>
</dd>
<dt><strong>ref_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">datetime object</span></dt>
<dd><p class="first last">reference time for current radar volume</p>
</dd>
<dt><strong>latlon_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">tolerance in latitude and longitude in deg.</p>
</dd>
<dt><strong>delta_rng, delta_azi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum range distance [m] and azimuth distance [degree] from the
central point of the evp containing data to average.</p>
</dd>
<dt><strong>hmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum height to plot [m].</p>
</dd>
<dt><strong>hres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height resolution [m].</p>
</dd>
<dt><strong>avg_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The type of averaging to perform. Can be either “mean” or “median”</p>
</dd>
<dt><strong>nvalid_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid points to accept average.</p>
</dd>
<dt><strong>interp_kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">type of interpolation when projecting to vertical grid: ‘none’,
or ‘nearest’, etc.
‘none’ will select from all data points within the regular grid
height bin the closest to the center of the bin.
‘nearest’ will select the closest data point to the center of the
height bin regardless if it is within the height bin or not.
Data points can be masked values
If another type of interpolation is selected masked values will be
eliminated from the data points before the interpolation</p>
</dd>
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QVP object or None</span></dt>
<dd><p class="first last">If it is None this is the QVP object where to store the data from the
current time step. Otherwise a new QVP object will be created</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qvp object</span></dt>
<dd><p class="first last">The computed enhanced vertical profile</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_l">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_l</code><span class="sig-paren">(</span><em>radar</em>, <em>rhohv_field=None</em>, <em>l_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_l"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_l" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Rhohv in logarithmic scale according to L=-log10(1-RhoHV)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>rhohv_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the RhoHV field used for the calculation</p>
</dd>
<dt><strong>l_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the L field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>l</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">L field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_noisedBZ">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_noisedBZ</code><span class="sig-paren">(</span><em>nrays</em>, <em>noisedBZ_val</em>, <em>rng</em>, <em>ref_dist</em>, <em>noise_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_noisedBZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_noisedBZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes noise in dBZ from reference noise value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>nrays: int</strong></dt>
<dd><p class="first last">number of rays in the reflectivity field</p>
</dd>
<dt><strong>noisedBZ_val: float</strong></dt>
<dd><p class="first last">Estimated noise value in dBZ at reference distance</p>
</dd>
<dt><strong>rng: np array of floats</strong></dt>
<dd><p class="first last">range vector in m</p>
</dd>
<dt><strong>ref_dist: float</strong></dt>
<dd><p class="first last">reference distance in Km</p>
</dd>
<dt><strong>noise_field: str</strong></dt>
<dd><p class="first last">name of the noise field to use</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>noisedBZ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">the noise field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_qvp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_qvp</code><span class="sig-paren">(</span><em>radar</em>, <em>field_names</em>, <em>ref_time=None</em>, <em>angle=0.0</em>, <em>ang_tol=1.0</em>, <em>hmax=10000.0</em>, <em>hres=50.0</em>, <em>avg_type='mean'</em>, <em>nvalid_min=30</em>, <em>interp_kind='none'</em>, <em>qvp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qvp.html#compute_qvp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_qvp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes quasi vertical profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>field_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of field names to add to the QVP</p>
</dd>
<dt><strong>ref_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">datetime object</span></dt>
<dd><p class="first last">reference time for current radar volume</p>
</dd>
<dt><strong>angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd><p class="first last">If the radar object contains a PPI volume, the sweep number to
use, if it contains an RHI volume the elevation angle.</p>
</dd>
<dt><strong>ang_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">If the radar object contains an RHI volume, the tolerance in the
elevation angle for the conversion into PPI</p>
</dd>
<dt><strong>hmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum height to plot [m].</p>
</dd>
<dt><strong>hres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height resolution [m].</p>
</dd>
<dt><strong>avg_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The type of averaging to perform. Can be either “mean” or “median”</p>
</dd>
<dt><strong>nvalid_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid points to accept average.</p>
</dd>
<dt><strong>interp_kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">type of interpolation when projecting to vertical grid: ‘none’,
or ‘nearest’, etc.
‘none’ will select from all data points within the regular grid
height bin the closest to the center of the bin.
‘nearest’ will select the closest data point to the center of the
height bin regardless if it is within the height bin or not.
Data points can be masked values
If another type of interpolation is selected masked values will be
eliminated from the data points before the interpolation</p>
</dd>
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QVP object or None</span></dt>
<dd><p class="first last">If it is None this is the QVP object where to store the data from the
current time step. Otherwise a new QVP object will be created</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qvp object</span></dt>
<dd><p class="first last">The computed QVP object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_rcs">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_rcs</code><span class="sig-paren">(</span><em>radar</em>, <em>kw2=0.93</em>, <em>pulse_width=None</em>, <em>beamwidth=None</em>, <em>freq=None</em>, <em>refl_field=None</em>, <em>rcs_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_rcs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_rcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the radar cross-section (assuming a point target) from radar
reflectivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>kw2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">water constant</p>
</dd>
<dt><strong>pulse_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">pulse width [s]</p>
</dd>
<dt><strong>beamwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">beamwidth [degree]</p>
</dd>
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar frequency [Hz]. If none it will be obtained from the radar
metadata</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity used for the calculations</p>
</dd>
<dt><strong>rcs_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the RCS field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rcs_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">RCS field and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_rcs_from_pr">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_rcs_from_pr</code><span class="sig-paren">(</span><em>radar</em>, <em>lmf=None</em>, <em>attg=None</em>, <em>radconst=None</em>, <em>tx_pwr=None</em>, <em>antenna_gain=None</em>, <em>lrx=0.0</em>, <em>ltx=0.0</em>, <em>lradome=0.0</em>, <em>freq=None</em>, <em>refl_field=None</em>, <em>rcs_field=None</em>, <em>neglect_gas_att=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_rcs_from_pr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_rcs_from_pr" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the radar cross-section (assuming a point target) from radar
reflectivity by first computing the received power and then the RCS from
it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>lmf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">matched filter losses</p>
</dd>
<dt><strong>attg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">1-way gas attenuation</p>
</dd>
<dt><strong>radconst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar constant</p>
</dd>
<dt><strong>tx_pwr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar transmitted power [dBm]</p>
</dd>
<dt><strong>antenna_gain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">antenna gain [dB]</p>
</dd>
<dt><strong>lrx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">receiver losses from the antenna feed to the reference point
(positive value) [dB]</p>
</dd>
<dt><strong>lradome</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">1-way losses due to the radome (positive value) [dB]</p>
</dd>
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar frequency [Hz]. If none it will be obtained from the radar
metadata</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity used for the calculations</p>
</dd>
<dt><strong>rcs_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the RCS field</p>
</dd>
<dt><strong>neglect_gas_att</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to neglect or not gas attenuation in the estimation of the
RCS</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rcs_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">RCS field and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_rqvp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_rqvp</code><span class="sig-paren">(</span><em>radar</em>, <em>field_names</em>, <em>ref_time=None</em>, <em>hmax=10000.0</em>, <em>hres=2.0</em>, <em>avg_type='mean'</em>, <em>nvalid_min=30</em>, <em>interp_kind='nearest'</em>, <em>rmax=50000.0</em>, <em>weight_power=2.0</em>, <em>qvp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qvp.html#compute_rqvp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_rqvp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes range-defined quasi vertical profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>field_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of field names to add to the QVP</p>
</dd>
<dt><strong>ref_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">datetime object</span></dt>
<dd><p class="first last">reference time for current radar volume</p>
</dd>
<dt><strong>hmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum height to plot [m].</p>
</dd>
<dt><strong>hres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height resolution [m].</p>
</dd>
<dt><strong>avg_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The type of averaging to perform. Can be either “mean” or “median”</p>
</dd>
<dt><strong>nvalid_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid points to accept average.</p>
</dd>
<dt><strong>interp_kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">type of interpolation when projecting to vertical grid: ‘none’,
or ‘nearest’, etc.
‘none’ will select from all data points within the regular grid
height bin the closest to the center of the bin.
‘nearest’ will select the closest data point to the center of the
height bin regardless if it is within the height bin or not.
Data points can be masked values
If another type of interpolation is selected masked values will be
eliminated from the data points before the interpolation</p>
</dd>
<dt><strong>rmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">ground range up to which the data is intended for use [m].</p>
</dd>
<dt><strong>weight_power</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Power p of the weighting function 1/abs(grng-(rmax-1))**p given to
the data outside the desired range. -1 will set the weight to 0.</p>
</dd>
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QVP object or None</span></dt>
<dd><p class="first last">If it is None this is the QVP object where to store the data from the
current time step. Otherwise a new QVP object will be created</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qvp object</span></dt>
<dd><p class="first last">The computed range defined quasi vertical profile</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_signal_power">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_signal_power</code><span class="sig-paren">(</span><em>radar</em>, <em>lmf=None</em>, <em>attg=None</em>, <em>radconst=None</em>, <em>lrx=0.0</em>, <em>lradome=0.0</em>, <em>refl_field=None</em>, <em>pwr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_signal_power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_signal_power" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes received signal power OUTSIDE THE RADOME in dBm from a
reflectivity field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>lmf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">matched filter losses</p>
</dd>
<dt><strong>attg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">1-way gas attenuation</p>
</dd>
<dt><strong>radconst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar constant</p>
</dd>
<dt><strong>lrx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">receiver losses from the antenna feed to the reference point
(positive value) [dB]</p>
</dd>
<dt><strong>lradome</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">1-way losses due to the radome (positive value) [dB]</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity used for the calculations</p>
</dd>
<dt><strong>pwr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the signal power field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>s_pwr_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">power field and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_snr">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_snr</code><span class="sig-paren">(</span><em>radar</em>, <em>refl_field=None</em>, <em>noise_field=None</em>, <em>snr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_snr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_snr" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes SNR from a reflectivity field and the noise in dBZ.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>refl_field, noise_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity and noise field used for the calculations</p>
</dd>
<dt><strong>snr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the SNR field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>snr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">the SNR field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_svp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_svp</code><span class="sig-paren">(</span><em>radar</em>, <em>field_names</em>, <em>lon</em>, <em>lat</em>, <em>angle</em>, <em>ref_time=None</em>, <em>ang_tol=1.0</em>, <em>latlon_tol=0.0005</em>, <em>delta_rng=15000.0</em>, <em>delta_azi=10</em>, <em>hmax=10000.0</em>, <em>hres=250.0</em>, <em>avg_type='mean'</em>, <em>nvalid_min=1</em>, <em>interp_kind='none'</em>, <em>qvp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qvp.html#compute_svp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_svp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes slanted vertical profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>field_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of field names to add to the QVP</p>
</dd>
<dt><strong>lat, lon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">latitude and longitude of the point of interest [deg]</p>
</dd>
<dt><strong>angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd><p class="first last">If the radar object contains a PPI volume, the sweep number to
use, if it contains an RHI volume the elevation angle.</p>
</dd>
<dt><strong>ref_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">datetime object</span></dt>
<dd><p class="first last">reference time for current radar volume</p>
</dd>
<dt><strong>ang_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">If the radar object contains an RHI volume, the tolerance in the
elevation angle for the conversion into PPI</p>
</dd>
<dt><strong>latlon_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">tolerance in latitude and longitude in deg.</p>
</dd>
<dt><strong>delta_rng, delta_azi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum range distance [m] and azimuth distance [degree] from the
central point of the evp containing data to average.</p>
</dd>
<dt><strong>hmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum height to plot [m].</p>
</dd>
<dt><strong>hres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height resolution [m].</p>
</dd>
<dt><strong>avg_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The type of averaging to perform. Can be either “mean” or “median”</p>
</dd>
<dt><strong>nvalid_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid points to accept average.</p>
</dd>
<dt><strong>interp_kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">type of interpolation when projecting to vertical grid: ‘none’,
or ‘nearest’, etc.
‘none’ will select from all data points within the regular grid
height bin the closest to the center of the bin.
‘nearest’ will select the closest data point to the center of the
height bin regardless if it is within the height bin or not.
Data points can be masked values
If another type of interpolation is selected masked values will be
eliminated from the data points before the interpolation</p>
</dd>
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QVP object or None</span></dt>
<dd><p class="first last">If it is None this is the QVP object where to store the data from the
current time step. Otherwise a new QVP object will be created</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qvp object</span></dt>
<dd><p class="first last">The computed slanted vertical profile</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_vol_refl">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_vol_refl</code><span class="sig-paren">(</span><em>radar</em>, <em>kw=0.93</em>, <em>freq=None</em>, <em>refl_field=None</em>, <em>vol_refl_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#compute_vol_refl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_vol_refl" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the volumetric reflectivity from the effective reflectivity
factor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
<dt><strong>kw</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">water constant</p>
</dd>
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None or float</span></dt>
<dd><p class="first last">radar frequency</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity used for the calculations</p>
</dd>
<dt><strong>vol_refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the volumetric reflectivity</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vol_refl_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">volumetric reflectivity and metadata in 10log10(cm^2 km^-3)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.compute_vp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">compute_vp</code><span class="sig-paren">(</span><em>radar</em>, <em>field_names</em>, <em>lon</em>, <em>lat</em>, <em>ref_time=None</em>, <em>latlon_tol=0.0005</em>, <em>hmax=10000.0</em>, <em>hres=50.0</em>, <em>interp_kind='none'</em>, <em>qvp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qvp.html#compute_vp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.compute_vp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes vertical profiles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>field_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of field names to add to the QVP</p>
</dd>
<dt><strong>lat, lon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">latitude and longitude of the point of interest [deg]</p>
</dd>
<dt><strong>ref_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">datetime object</span></dt>
<dd><p class="first last">reference time for current radar volume</p>
</dd>
<dt><strong>latlon_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">tolerance in latitude and longitude in deg.</p>
</dd>
<dt><strong>hmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum height to plot [m].</p>
</dd>
<dt><strong>hres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The height resolution [m].</p>
</dd>
<dt><strong>interp_kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">type of interpolation when projecting to vertical grid: ‘none’,
or ‘nearest’, etc.
‘none’ will select from all data points within the regular grid
height bin the closest to the center of the bin.
‘nearest’ will select the closest data point to the center of the
height bin regardless if it is within the height bin or not.
Data points can be masked values
If another type of interpolation is selected masked values will be
eliminated from the data points before the interpolation</p>
</dd>
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QVP object or None</span></dt>
<dd><p class="first last">If it is None this is the QVP object where to store the data from the
current time step. Otherwise a new QVP object will be created</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qvp object</span></dt>
<dd><p class="first last">The computed vertical profile</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.detect_ml">
<code class="descclassname">pyart.retrieve.</code><code class="descname">detect_ml</code><span class="sig-paren">(</span><em>radar</em>, <em>gatefilter=None</em>, <em>fill_value=None</em>, <em>refl_field=None</em>, <em>rhohv_field=None</em>, <em>ml_field=None</em>, <em>ml_pos_field=None</em>, <em>iso0_field=None</em>, <em>max_range=20000</em>, <em>detect_threshold=0.02</em>, <em>interp_holes=False</em>, <em>max_length_holes=250</em>, <em>check_min_length=True</em>, <em>get_iso0=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/ml.html#detect_ml"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.detect_ml" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects the melting layer (ML) using the reflectivity and copolar
correlation coefficient. Internally it uses RHIs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ml_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">radar-like object</span></dt>
<dd><p class="first last">A radar-like object containing the field melting layer height with
the bottom (at range position 0) and top (at range position one) of
the melting layer at each ray</p>
</dd>
<dt><strong>ml_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary containg the position of the range gate respect to the
melting layer and metadata</p>
</dd>
<dt><strong>iso0_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict or None</span></dt>
<dd><p class="first last">A dictionary containing the distance respect to the melting layer
and metadata</p>
</dd>
<dt><strong>all_ml</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary containing internal parameters in polar and cartesian
coordinates</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_a">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_a</code><span class="sig-paren">(</span><em>radar</em>, <em>alpha=None</em>, <em>beta=None</em>, <em>a_field=None</em>, <em>rr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate from specific attenuation using alpha power law</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>alpha,beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">Optional. factor (alpha) and exponent (beta) of the power law.
If not set the factors are going to be determined according
to the radar frequency</p>
</dd>
<dt><strong>a_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the specific attenuation field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Diederich M., Ryzhkov A., Simmer C., Zhang P. and Tromel S., 2015: Use of
Specific Attenuation for Rainfall Measurement at X-Band Radar Wavelenghts.
Part I: Radar Calibration and Partial Beam Blockage Estimation. Journal of
Hydrometeorology, 16, 487-502.</p>
<p>Ryzhkov A., Diederich M., Zhang P. and Simmer C., 2014: Potential
Utilization of Specific Attenuation for Rainfall Estimation, Mitigation of
Partial Beam Blockage, and Radar Networking. Journal of Atmospheric and
Oceanic Technology, 31, 599-619.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_hydro">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_hydro</code><span class="sig-paren">(</span><em>radar</em>, <em>alphazr=0.0376</em>, <em>betazr=0.6112</em>, <em>alphazs=0.1</em>, <em>betazs=0.5</em>, <em>alphaa=None</em>, <em>betaa=None</em>, <em>mp_factor=0.6</em>, <em>refl_field=None</em>, <em>a_field=None</em>, <em>hydro_field=None</em>, <em>rr_field=None</em>, <em>master_field=None</em>, <em>thresh=None</em>, <em>thresh_max=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_hydro"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_hydro" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate using different relations between R and the
polarimetric variables depending on the hydrometeor type</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>alphazr,betazr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">factor (alpha) and exponent (beta) of the z-r power law for rain.</p>
</dd>
<dt><strong>alphazs,betazs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">factor (alpha) and exponent (beta) of the z-s power law for snow.</p>
</dd>
<dt><strong>alphaa,betaa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">Optional. factor (alpha) and exponent (beta) of the a-r power law.
If not set the factors are going to be determined according
to the radar frequency</p>
</dd>
<dt><strong>mp_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">factor applied to z-r relation in the melting layer</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity field to use</p>
</dd>
<dt><strong>a_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the specific attenuation field to use</p>
</dd>
<dt><strong>hydro_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the hydrometeor classification field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
<dt><strong>master_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the field that is going to act as master. Has to be
either refl_field or a_field. Default is a_field</p>
</dd>
<dt><strong>thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">value of the threshold that determines when to use the slave
field. The default will depend on the master field</p>
</dd>
<dt><strong>thresh_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">If true the master field is used up to the thresh value maximum.
Otherwise the master field is not used below thresh value.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_kdp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_kdp</code><span class="sig-paren">(</span><em>radar</em>, <em>alpha=None</em>, <em>beta=None</em>, <em>kdp_field=None</em>, <em>rr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_kdp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_kdp" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate from kdp using alpha power law</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>alpha,beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">Optional. factor (alpha) and exponent (beta) of the power law.
If not set the factors are going to be determined according
to the radar frequency</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the specific differential phase field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_z">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_z</code><span class="sig-paren">(</span><em>radar</em>, <em>alpha=0.0376</em>, <em>beta=0.6112</em>, <em>refl_field=None</em>, <em>rr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate from reflectivity using a power law</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>alpha,beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">factor (alpha) and exponent (beta) of the power law</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_za">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_za</code><span class="sig-paren">(</span><em>radar</em>, <em>alphaz=0.0376</em>, <em>betaz=0.6112</em>, <em>alphaa=None</em>, <em>betaa=None</em>, <em>refl_field=None</em>, <em>a_field=None</em>, <em>rr_field=None</em>, <em>master_field=None</em>, <em>thresh=None</em>, <em>thresh_max=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_za"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_za" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate from a blending of power law r-alpha and r-z
relations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>alphaz,betaz</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">factor (alpha) and exponent (beta) of the z-r power law.</p>
</dd>
<dt><strong>alphaa,betaa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">Optional. factor (alpha) and exponent (beta) of the a-r power law.
If not set the factors are going to be determined according
to the radar frequency</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity field to use</p>
</dd>
<dt><strong>a_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the specific attenuation field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
<dt><strong>master_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the field that is going to act as master. Has to be
either refl_field or kdp_field. Default is refl_field</p>
</dd>
<dt><strong>thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">value of the threshold that determines when to use the slave
field.</p>
</dd>
<dt><strong>thresh_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">If true the master field is used up to the thresh value maximum.
Otherwise the master field is not used below thresh value.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain_master</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_zkdp">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_zkdp</code><span class="sig-paren">(</span><em>radar</em>, <em>alphaz=0.0376</em>, <em>betaz=0.6112</em>, <em>alphakdp=None</em>, <em>betakdp=None</em>, <em>refl_field=None</em>, <em>kdp_field=None</em>, <em>rr_field=None</em>, <em>master_field=None</em>, <em>thresh=None</em>, <em>thresh_max=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_zkdp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_zkdp" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate from a blending of power law r-kdp and r-z
relations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>alphaz,betaz</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">factor (alpha) and exponent (beta) of the z-r power law.</p>
</dd>
<dt><strong>alphakdp, betakdp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">floats</span></dt>
<dd><p class="first last">Optional. factor (alpha) and exponent (beta) of the kdp-r power law.
If not set the factors are going to be determined according
to the radar frequency</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity field to use</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the specific differential phase field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
<dt><strong>master_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the field that is going to act as master. Has to be
either refl_field or kdp_field. Default is refl_field</p>
</dd>
<dt><strong>thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">value of the threshold that determines when to use the slave
field [mm/h].</p>
</dd>
<dt><strong>thresh_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">If true the master field is used up to the thresh value maximum.
Otherwise the master field is not used below thresh value.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain_master</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_rain_rate_zpoly">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_rain_rate_zpoly</code><span class="sig-paren">(</span><em>radar</em>, <em>refl_field=None</em>, <em>rr_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qpe.html#est_rain_rate_zpoly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_rain_rate_zpoly" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates rainfall rate from reflectivity using a polynomial Z-R relation
developed at McGill University</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the reflectivity field to use</p>
</dd>
<dt><strong>rr_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the rainfall rate field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rain</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the rainfall rate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_vertical_windshear">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_vertical_windshear</code><span class="sig-paren">(</span><em>radar</em>, <em>az_tol=0.5</em>, <em>wind_field=None</em>, <em>windshear_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/wind.html#est_vertical_windshear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_vertical_windshear" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates wind shear.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>az_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">azimuth tolerance to consider gate on top of selected one</p>
</dd>
<dt><strong>wind_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the horizontal wind velocity field</p>
</dd>
<dt><strong>windshear_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the vertical wind shear field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>windshear</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the wind shear field</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_wind_profile">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_wind_profile</code><span class="sig-paren">(</span><em>radar</em>, <em>npoints_min=6</em>, <em>azi_spacing_max=45.0</em>, <em>vel_diff_max=10.0</em>, <em>sign=1</em>, <em>rad_vel_field=None</em>, <em>u_vel_field=None</em>, <em>v_vel_field=None</em>, <em>w_vel_field=None</em>, <em>vel_est_field=None</em>, <em>vel_std_field=None</em>, <em>vel_diff_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/wind.html#est_wind_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_wind_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the vertical wind profile using VAD techniques</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>npoints_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of points in the VAD to retrieve wind components.
0 will retrieve them regardless</p>
</dd>
<dt><strong>azi_spacing_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum spacing between valid gates in the VAD to retrieve wind
components. 0 will retrieve them regardless.</p>
</dd>
<dt><strong>vel_diff_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum velocity difference allowed between retrieved and measured
radial velocity at each range gate. Gates exceeding this threshold
will be removed and VAD will be recomputed. If -1 there will not be
a second pass.</p>
</dd>
<dt><strong>sign</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Sign convention which the radial velocities in the volume created
from the sounding data will will. This should match the convention
used in the radar data. A value of 1 represents when positive values
velocities are towards the radar, -1 represents when negative
velocities are towards the radar.</p>
</dd>
<dt><strong>rad_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the measured radial velocity field</p>
</dd>
<dt><strong>u_vel_field, v_vel_field, w_vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">names of the 3 wind components fields</p>
</dd>
<dt><strong>vel_est_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the retrieved radial Doppler velocity field</p>
</dd>
<dt><strong>vel_std_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the standard deviation of the velocity retrieval field</p>
</dd>
<dt><strong>vel_diff_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the diference between retrieved and measured radial velocity
field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>wind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the estimated wind velocity</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.est_wind_vel">
<code class="descclassname">pyart.retrieve.</code><code class="descname">est_wind_vel</code><span class="sig-paren">(</span><em>radar</em>, <em>vert_proj=False</em>, <em>vel_field=None</em>, <em>wind_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/wind.html#est_wind_vel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.est_wind_vel" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates wind velocity. Projects the radial wind component to the
horizontal or vertical of the azimuth plane. It assumes that the
orthogonal component is negligible.</p>
<dl class="docutils">
<dt>The horizontal wind component is given by:</dt>
<dd>v = v_r*cos(el)-v_el*sin(el)+v_az</dd>
<dt>where:</dt>
<dd>v_r is the radial wind component (measured by the radar)
v_el is the perpendicular wind component in the azimuth plane.
v_az is the horizontal component perpendicular to the radial
direction and the azimuth plane
el is the elevation</dd>
<dt>The horizontal wind component in the azimuth plane is given by:</dt>
<dd>v_h = v_r*cos(el) - v_el*sin(el)</dd>
<dt>which since we do not know v_el we assume:</dt>
<dd>v_h ~ v_r*cos(el)</dd>
</dl>
<p>This assumption holds for small elevation angles</p>
<dl class="docutils">
<dt>The vertical wind component in the azimuth plane is given by:</dt>
<dd>v_h = v_r*sin(el) - v_el*cos(el)</dd>
<dt>which since we do not know v_el we assume:</dt>
<dd>v_h ~ v_r*sin(el)</dd>
</dl>
<p>This assumption holds for angles close to 90 deg</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object</p>
</dd>
<dt><strong>vert_proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">If true estimates the vertical projection, otherwise the horizontal</p>
</dd>
<dt><strong>vel_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the velocity field</p>
</dd>
<dt><strong>wind_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of the velocity field</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>wind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionary containing the estimated wind velocity</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.fetch_radar_time_profile">
<code class="descclassname">pyart.retrieve.</code><code class="descname">fetch_radar_time_profile</code><span class="sig-paren">(</span><em>sonde_dset</em>, <em>radar</em>, <em>time_key='time'</em>, <em>height_key='height'</em>, <em>nvars=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/gate_id.html#fetch_radar_time_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.fetch_radar_time_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the correct profile from a interpolated sonde.</p>
<p>This is an ARM specific method which extract the correct profile out of
netCDF Variables from a Interpolated Sonde VAP for the volume start time
of a radar object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sonde_dset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dataset</span></dt>
<dd><p class="first last">Interpolate sonde Dataset.</p>
</dd>
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object from which the nearest profile will be found.</p>
</dd>
<dt><strong>time_key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">Key to find a CF startard time variable</p>
</dd>
<dt><strong>height_key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, optional</span></dt>
<dd><p class="first last">Key to find profile height data</p>
</dd>
<dt><strong>nvars</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">NetCDF variable to generated profiles for.  If None (the default) all
variables with dimension of time, height will be found in ncvars.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>return_dic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Profiles at the start time of the radar</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.get_coeff_attg">
<code class="descclassname">pyart.retrieve.</code><code class="descname">get_coeff_attg</code><span class="sig-paren">(</span><em>freq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/simple_moment_calculations.html#get_coeff_attg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.get_coeff_attg" title="Permalink to this definition">¶</a></dt>
<dd><p>get the 1-way gas attenuation for a particular frequency</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar frequency [Hz]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>attg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">1-way gas attenuation</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.get_freq_band">
<code class="descclassname">pyart.retrieve.</code><code class="descname">get_freq_band</code><span class="sig-paren">(</span><em>freq</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/echo_class.html#get_freq_band"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.get_freq_band" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the frequency band name (S, C, X, …)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">radar frequency [Hz]</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>freq_band</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">frequency band name</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.grid_displacement_pc">
<code class="descclassname">pyart.retrieve.</code><code class="descname">grid_displacement_pc</code><span class="sig-paren">(</span><em>grid1</em>, <em>grid2</em>, <em>field</em>, <em>level</em>, <em>return_value='pixels'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/advection.html#grid_displacement_pc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.grid_displacement_pc" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the grid displacement using phase correlation.</p>
<p>See:
<a class="reference external" href="http://en.wikipedia.org/wiki/Phase_correlation">http://en.wikipedia.org/wiki/Phase_correlation</a></p>
<p>Implementation inspired by Christoph Gohlke:
<a class="reference external" href="http://www.lfd.uci.edu/~gohlke/code/imreg.py.html">http://www.lfd.uci.edu/~gohlke/code/imreg.py.html</a></p>
<p>Note that the grid must have the same dimensions in x and y and assumed to
have constant spacing in these dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grid1, grid2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Grid</span></dt>
<dd><p class="first last">Py-ART Grid objects separated in time and square in x/y.</p>
</dd>
<dt><strong>field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Field to calculate advection from. Field must be in both grid1
and grid2.</p>
</dd>
<dt><strong>level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The vertical (z) level of the grid to use in the calculation.</p>
</dd>
<dt><strong>return_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">‘pixels’, ‘distance’ or ‘velocity’. Distance in pixels (default)
or meters or velocity vector in m/s.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>displacement</strong> <span class="classifier-delimiter">:</span> <span class="classifier">two-tuple</span></dt>
<dd><p class="first last">Calculated displacement in units of y and x.  Value returned in
integers if pixels, otherwise floats.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.grid_shift">
<code class="descclassname">pyart.retrieve.</code><code class="descname">grid_shift</code><span class="sig-paren">(</span><em>grid</em>, <em>advection</em>, <em>trim_edges=0</em>, <em>field_list=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/advection.html#grid_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.grid_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift a grid by a certain number of pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grid: Grid</strong></dt>
<dd><p class="first last">Py-ART Grid object.</p>
</dd>
<dt><strong>advection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">two-tuple of floats</span></dt>
<dd><p class="first last">Number of Pixels to shift the image by.</p>
</dd>
<dt><strong>trim_edges: integer, optional</strong></dt>
<dd><p class="first last">Edges to cut off the grid and axes, both x and y. Defaults to zero.</p>
</dd>
<dt><strong>field_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">List of fields to include in new grid. None, the default, includes all
fields from the input grid.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shifted_grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Grid</span></dt>
<dd><p class="first last">Grid with fields shifted and, if requested, subset.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.hydroclass_semisupervised">
<code class="descclassname">pyart.retrieve.</code><code class="descname">hydroclass_semisupervised</code><span class="sig-paren">(</span><em>radar</em>, <em>mass_centers=None</em>, <em>weights=array([1.</em>, <em>1.</em>, <em>1.</em>, <em>0.75</em>, <em>0.5 ])</em>, <em>value=50.0</em>, <em>refl_field=None</em>, <em>zdr_field=None</em>, <em>rhv_field=None</em>, <em>kdp_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>hydro_field=None</em>, <em>entropy_field=None</em>, <em>temp_ref='temperature'</em>, <em>compute_entropy=False</em>, <em>output_distances=False</em>, <em>vectorize=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/echo_class.html#hydroclass_semisupervised"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.hydroclass_semisupervised" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies precipitation echoes following the approach by
Besic et al (2016)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fields_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary containing the retrieved fields</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>mass_centers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray 2D</span></dt>
<dd><p class="first last">The centroids for each variable and hydrometeor class in (nclasses,
nvariables)</p>
</dd>
<dt><strong>weights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray 1D</span></dt>
<dd><p class="first last">The weight given to each variable.</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The value controlling the rate of decay in the distance transformation</p>
</dd>
<dt><strong>refl_field, zdr_field, rhv_field, kdp_field, temp_field, iso0_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Inputs. Field names within the radar object which represent the
horizonal reflectivity, the differential reflectivity, the copolar
correlation coefficient, the specific differential phase, the
temperature and the height respect to the iso0 fields. A value of None
for any of these parameters will use the default field name as defined
in the Py-ART configuration file.</p>
</dd>
<dt><strong>hydro_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Output. Field name which represents the hydrometeor class field.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be either temperature
or height_over_iso0</p>
</dd>
<dt><strong>compute_entropy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, the entropy is computed</p>
</dd>
<dt><strong>output_distances</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, the normalized distances to the centroids for each
hydrometeor are provided as output</p>
</dd>
<dt><strong>vectorize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, a vectorized version of the class assignation is going to be
used</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Besic, N., Figueras i Ventura, J., Grazioli, J., Gabella, M., Germann, U.,
and Berne, A.: Hydrometeor classification through statistical clustering
of polarimetric radar measurements: a semi-supervised approach,
Atmos. Meas. Tech., 9, 4425-4445, doi:10.5194/amt-9-4425-2016, 2016</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.kdp_leastsquare_double_window">
<code class="descclassname">pyart.retrieve.</code><code class="descname">kdp_leastsquare_double_window</code><span class="sig-paren">(</span><em>radar</em>, <em>swind_len=11</em>, <em>smin_valid=6</em>, <em>lwind_len=31</em>, <em>lmin_valid=16</em>, <em>zthr=40.0</em>, <em>phidp_field=None</em>, <em>refl_field=None</em>, <em>kdp_field=None</em>, <em>vectorize=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/kdp_proc.html#kdp_leastsquare_double_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.kdp_leastsquare_double_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the specific differential phase (KDP) from differential phase data
using a piecewise least square method. For optimal results PhiDP should
be already smoothed and clutter filtered out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object.</p>
</dd>
<dt><strong>swind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The lenght of the short moving window.</p>
</dd>
<dt><strong>smin_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid bins to consider the retrieval valid when
using the short moving window</p>
</dd>
<dt><strong>lwind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The lenght of the long moving window.</p>
</dd>
<dt><strong>lmin_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid bins to consider the retrieval valid when
using the long moving window</p>
</dd>
<dt><strong>zthr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">reflectivity value above which the short window is used</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the differential
phase shift. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the reflectivity.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the specific
differential phase shift. A value of None will use the default field
name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>vectorize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">whether to use a vectorized version of the least square method</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kdp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Retrieved specific differential phase data and metadata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.kdp_leastsquare_single_window">
<code class="descclassname">pyart.retrieve.</code><code class="descname">kdp_leastsquare_single_window</code><span class="sig-paren">(</span><em>radar</em>, <em>wind_len=11</em>, <em>min_valid=6</em>, <em>phidp_field=None</em>, <em>kdp_field=None</em>, <em>vectorize=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/kdp_proc.html#kdp_leastsquare_single_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.kdp_leastsquare_single_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the specific differential phase (KDP) from differential phase data
using a piecewise least square method. For optimal results PhiDP should
be already smoothed and clutter filtered out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object.</p>
</dd>
<dt><strong>wind_len</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The lenght of the moving window.</p>
</dd>
<dt><strong>min_valid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Minimum number of valid bins to consider the retrieval valid</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the differential
phase shift. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field name within the radar object which represent the specific
differential phase shift. A value of None will use the default field
name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>vectorize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">whether to use a vectorized version of the least square method</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kdp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Retrieved specific differential phase data and metadata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.kdp_maesaka">
<code class="descclassname">pyart.retrieve.</code><code class="descname">kdp_maesaka</code><span class="sig-paren">(</span><em>radar</em>, <em>gatefilter=None</em>, <em>method='cg'</em>, <em>backscatter=None</em>, <em>Clpf=1.0</em>, <em>length_scale=None</em>, <em>first_guess=0.01</em>, <em>finite_order='low'</em>, <em>fill_value=None</em>, <em>proc=1</em>, <em>psidp_field=None</em>, <em>kdp_field=None</em>, <em>phidp_field=None</em>, <em>debug=False</em>, <em>verbose=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/kdp_proc.html#kdp_maesaka"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.kdp_maesaka" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the specific differential phase (KDP) from corrected (e.g.,
unfolded) total differential phase data based on the variational method
outlined in Maesaka et al. (2012). This method assumes a monotonically
increasing propagation differential phase (PHIDP) with increasing range
from the radar, and therefore is limited to rainfall below the melting
layer and/or warm clouds at weather radar frequencies (e.g., S-, C-, and
X-band). This method currently only supports radar data with constant range
resolution.</p>
<p>Following the notation of Maesaka et al. (2012), the primary control
variable k is proportional to KDP,</p>
<blockquote>
<div>k**2 = 2 * KDP * dr</div></blockquote>
<p>which, because of the square, assumes that KDP always takes a positive
value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar containing differential phase field.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter</span></dt>
<dd><p class="first last">A GateFilter indicating radar gates that should be excluded when
analysing differential phase measurements.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Type of scipy.optimize method to use when minimizing the cost
functional. The default method uses a nonlinear conjugate gradient
algorithm. In Maesaka et al. (2012) they use the Broyden-Fletcher-
Goldfarb-Shanno (BFGS) algorithm, however for large functional size
(e.g., 100K+ variables) this algorithm is considerably slower than a
conjugate gradient algorithm.</p>
</dd>
<dt><strong>backscatter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">optional</span></dt>
<dd><p class="first last">Define the backscatter differential phase. If None, the backscatter
differential phase is set to zero for all range gates. Note that
backscatter differential phase can be parameterized using attentuation
corrected differential reflectivity.</p>
</dd>
<dt><strong>Clpf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">The low-pass filter (radial smoothness) constraint weight as in
equation (15) of Maesaka et al. (2012).</p>
</dd>
<dt><strong>length_scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Length scale in meters used to bring the dimension and magnitude of the
low-pass filter cost functional in line with the observation cost
functional. If None, the length scale is set to the range resolution.</p>
</dd>
<dt><strong>first_guess</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">First guess for control variable k. Since k is proportional to the
square root of KDP, the first guess should be close to zero to signify
a KDP field close to 0 deg/km everywhere. However, the first guess
should not be exactly zero in order to avoid convergence criteria after
the first iteration. In fact it is recommended to use a value closer to
one than zero.</p>
</dd>
<dt><strong>finite_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘low’ or ‘high’, optional</span></dt>
<dd><p class="first last">The finite difference accuracy to use when computing derivatives.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximum number of iterations to perform during cost functional
minimization. The maximum number of iterations are only performed if
convergence criteria are not met. For variational schemes such as this
one, it is generally not recommended to try and achieve convergence
criteria since the values of the cost functional and/or its gradient
norm are somewhat arbitrary.</p>
</dd>
<dt><strong>fill_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value indicating missing or bad data in differential phase field.</p>
</dd>
<dt><strong>proc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of parallel threads (CPUs) to use. Currently no
multiprocessing capability exists.</p>
</dd>
<dt><strong>psidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Total differential phase field. If None, the default field name must be
specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Specific differential phase field. If None, the default field name must
be specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Propagation differential phase field. If None, the default field name
must be specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>debug</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to print debugging information, False to suppress.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">True to print relevant information, False to suppress.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kdp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Retrieved specific differential phase data and metadata.</p>
</dd>
<dt><strong>phidpf_dict, phidpr_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Retrieved forward and reverse direction propagation differential phase
data and metadata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Maesaka, T., Iwanami, K. and Maki, M., 2012: “Non-negative KDP Estimation
by Monotone Increasing PHIDP Assumption below Melting Layer”. The Seventh
European Conference on Radar in Meteorology and Hydrology.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.kdp_schneebeli">
<code class="descclassname">pyart.retrieve.</code><code class="descname">kdp_schneebeli</code><span class="sig-paren">(</span><em>radar</em>, <em>gatefilter=None</em>, <em>fill_value=None</em>, <em>psidp_field=None</em>, <em>kdp_field=None</em>, <em>phidp_field=None</em>, <em>band='C'</em>, <em>rcov=0</em>, <em>pcov=0</em>, <em>prefilter_psidp=False</em>, <em>filter_opt=None</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/kdp_proc.html#kdp_schneebeli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.kdp_schneebeli" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates Kdp with the Kalman filter method by Schneebeli and al. (2014)
for a set of psidp measurements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar containing differential phase field.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter, optional</span></dt>
<dd><p class="first last">A GateFilter indicating radar gates that should be excluded when
analysing differential phase measurements.</p>
</dd>
<dt><strong>fill_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value indicating missing or bad data in differential phase field, if
not specified, the default in the Py-ART configuration file will be
used</p>
</dd>
<dt><strong>psidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Total differential phase field. If None, the default field name must be
specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Specific differential phase field. If None, the default field name must
be specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Propagation differential phase field. If None, the default field name
must be specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>band</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, optional</span></dt>
<dd><p class="first last">Radar frequency band string. Accepted “X”, “C”, “S” (capital
or not). The band is used to compute intercepts -c and slope b of the
delta = b*Kdp+c relation</p>
</dd>
<dt><strong>rcov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3x3 float array, optional</span></dt>
<dd><p class="first last">Measurement error covariance matrix</p>
</dd>
<dt><strong>pcov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">4x4 float array, optional</span></dt>
<dd><p class="first last">Scaled state transition error covariance matrix</p>
</dd>
<dt><strong>prefilter_psidp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If set, the psidp measurements will first be filtered with the
filter_psidp method, which can improve the quality of the final Kdp</p>
</dd>
<dt><strong>filter_opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">The arguments for the prefilter_psidp method, if empty, the defaults
arguments of this method will be used</p>
</dd>
<dt><strong>parallel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Flag to enable parallel computation (one core for every psidp profile)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kdp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Retrieved specific differential phase data and metadata.</p>
</dd>
<dt><strong>kdp_std_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Estimated specific differential phase standard dev. data and metadata.</p>
</dd>
<dt><strong>phidpr_dict,: dict</strong></dt>
<dd><p class="first last">Retrieved differential phase data and metadata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Schneebeli, M., Grazioli, J., and Berne, A.: Improved Estimation
of the Specific Differential Phase SHIFT Using a Compilation of
Kalman Filter Ensembles, IEEE T. Geosci. Remote Sens., 52,
5137-5149, doi:10.1109/TGRS.2013.2287017, 2014.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.kdp_vulpiani">
<code class="descclassname">pyart.retrieve.</code><code class="descname">kdp_vulpiani</code><span class="sig-paren">(</span><em>radar</em>, <em>gatefilter=None</em>, <em>fill_value=None</em>, <em>psidp_field=None</em>, <em>kdp_field=None</em>, <em>phidp_field=None</em>, <em>band='C'</em>, <em>windsize=10</em>, <em>n_iter=10</em>, <em>interp=False</em>, <em>prefilter_psidp=False</em>, <em>filter_opt=None</em>, <em>parallel=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/kdp_proc.html#kdp_vulpiani"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.kdp_vulpiani" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates Kdp with the Vulpiani method for a 2D array of psidp measurements
with the first dimension being the distance from radar and the second
dimension being the angles (azimuths for PPI, elev for RHI).The input psidp
is assumed to be pre-filtered (for ex. with the filter_psidp function)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar containing differential phase field.</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter, optional</span></dt>
<dd><p class="first last">A GateFilter indicating radar gates that should be excluded when
analysing differential phase measurements.</p>
</dd>
<dt><strong>fill_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Value indicating missing or bad data in differential phase field, if
not specified, the default in the Py-ART configuration file will be
used</p>
</dd>
<dt><strong>psidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Total differential phase field. If None, the default field name must be
specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>kdp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Specific differential phase field. If None, the default field name must
be specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>phidp_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Propagation differential phase field. If None, the default field name
must be specified in the Py-ART configuration file.</p>
</dd>
<dt><strong>band</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, optional</span></dt>
<dd><p class="first last">Radar frequency band string. Accepted “X”, “C”, “S” (capital
or not). It is used to set default boundaries for expected
values of Kdp.</p>
</dd>
<dt><strong>windsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Size in # of gates of the range derivative window. Should be even.</p>
</dd>
<dt><strong>n_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of iterations of the method. Default is 10.</p>
</dd>
<dt><strong>interp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If True, all the nans are interpolated.The advantage is that less data
are lost (the iterations in fact are “eating the edges”) but some
non-linear errors may be introduced.</p>
</dd>
<dt><strong>prefilter_psidp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If set, the psidp measurements will first be filtered with the
filter_psidp method, which can improve the quality of the final Kdp.</p>
</dd>
<dt><strong>filter_opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">The arguments for the prefilter_psidp method, if empty, the defaults
arguments of this method will be used.</p>
</dd>
<dt><strong>parallel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Flag to enable parallel computation (one core for every psidp profile).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>kdp_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Retrieved specific differential phase data and metadata.</p>
</dd>
<dt><strong>phidpr_dict,: dict</strong></dt>
<dd><p class="first last">Retrieved differential phase data and metadata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Gianfranco Vulpiani, Mario Montopoli, Luca Delli Passeri, Antonio G. Gioia,
Pietro Giordano, and Frank S. Marzano, 2012: On the Use of Dual-Polarized
C-Band Radar for Operational Rainfall Retrieval in Mountainous Areas.
J. Appl. Meteor. Climatol., 51, 405-425, doi: 10.1175/JAMC-D-10-05024.1.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.map_profile_to_gates">
<code class="descclassname">pyart.retrieve.</code><code class="descname">map_profile_to_gates</code><span class="sig-paren">(</span><em>profile</em>, <em>heights</em>, <em>radar</em>, <em>toa=None</em>, <em>profile_field=None</em>, <em>height_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/gate_id.html#map_profile_to_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.map_profile_to_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a profile of a variable map it to the gates of radar assuming 4/3Re.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>profile</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Profile array to map.</p>
</dd>
<dt><strong>heights</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Monotonically increasing heights in meters with same shape as profile.</p>
</dd>
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar to map to</p>
</dd>
<dt><strong>toa: float, optional</strong></dt>
<dd><p class="first last">Top of atmosphere, where to use profile up to. If None check for
mask and use lowest element, if no mask uses whole profile.</p>
</dd>
<dt><strong>height_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name to use for height field metadata.  None will use the default field
name from the Py-ART configuration file.</p>
</dd>
<dt><strong>profile_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name to use for interpolate profile field metadata.  None will use the
default field name from the Py-ART configuration file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>height_dict, profile_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Field dictionaries containing the height of the gates and the profile
interpolated onto the radar gates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.melting_layer_giangrande">
<code class="descclassname">pyart.retrieve.</code><code class="descname">melting_layer_giangrande</code><span class="sig-paren">(</span><em>radar</em>, <em>nVol=3</em>, <em>maxh=6000.0</em>, <em>hres=50.0</em>, <em>rmin=1000.0</em>, <em>elmin=4.0</em>, <em>elmax=10.0</em>, <em>rhomin=0.75</em>, <em>rhomax=0.94</em>, <em>zhmin=20.0</em>, <em>hwindow=500.0</em>, <em>mlzhmin=30.0</em>, <em>mlzhmax=50.0</em>, <em>mlzdrmin=1.0</em>, <em>mlzdrmax=5.0</em>, <em>htol=500.0</em>, <em>ml_bottom_diff_max=1000.0</em>, <em>time_accu_max=1800.0</em>, <em>nml_points_min=None</em>, <em>wlength=20.0</em>, <em>percentile_bottom=0.3</em>, <em>percentile_top=0.9</em>, <em>interpol=True</em>, <em>time_nodata_allowed=3600.0</em>, <em>refl_field=None</em>, <em>zdr_field=None</em>, <em>rhv_field=None</em>, <em>temp_field=None</em>, <em>iso0_field=None</em>, <em>ml_field=None</em>, <em>ml_pos_field=None</em>, <em>temp_ref=None</em>, <em>get_iso0=False</em>, <em>ml_global=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/ml.html#melting_layer_giangrande"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.melting_layer_giangrande" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects the melting layer following the approach by Giangrande et al
(2008)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">radar</span></dt>
<dd><p class="first last">radar object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ml_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">radar-like object</span></dt>
<dd><p class="first last">A radar-like object containing the field melting layer height with
the bottom (at range position 0) and top (at range position one) of
the melting layer at each ray</p>
</dd>
<dt><strong>ml_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary containg the position of the range gate respect to the
melting layer and metadata</p>
</dd>
<dt><strong>iso0_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict or None</span></dt>
<dd><p class="first last">A dictionary containing the distance respect to the melting layer
and metadata</p>
</dd>
<dt><strong>ml_global</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict or None</span></dt>
<dd><p class="first last">stack of previous volume data to introduce some time dependency. Its
max size is controlled by the nVol parameter. It is always in
(pseudo-)RHI mode.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>nVol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of volume scans to aggregate</p>
</dd>
<dt><strong>maxh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum possible height of the melting layer [m MSL]</p>
</dd>
<dt><strong>hres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Step of the height of the melting layer [m]</p>
</dd>
<dt><strong>rmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum range from radar where to look for melting layer contaminated
range gates [m]</p>
</dd>
<dt><strong>elmin, elmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum elevation angles where to look for melting layer
contaminated range gates [degree]</p>
</dd>
<dt><strong>rhomin, rhomax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">min and max rhohv to consider pixel potential melting layer pixel</p>
</dd>
<dt><strong>zhmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum reflectivity level of a range gate to consider it a potential
melting layer gate [dBZ]</p>
</dd>
<dt><strong>hwindow</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum distance (in range) from potential melting layer gate where to
look for a maximum [m]</p>
</dd>
<dt><strong>mlzhmin, mlzhmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum values that a peak in reflectivity within the
melting layer may have to consider the range gate melting layer
contaminated [dBZ]</p>
</dd>
<dt><strong>mlzdrmin, mlzdrmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum and maximum values that a peak in differential reflectivity
within the melting layer may have to consider the range gate melting
layer contaminated [dB]</p>
</dd>
<dt><strong>htol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">maximum distance from the iso0 coming from model allowed to consider
the range gate melting layer contaminated [m]</p>
</dd>
<dt><strong>ml_bottom_dif_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum distance from the bottom of the melting layer computed in the
previous time step to consider a range gate melting layer contaminated
[m]</p>
</dd>
<dt><strong>time_accu_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum time allowed to accumulate data from consecutive scans [s]</p>
</dd>
<dt><strong>nml_points_min</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">minimum number of melting layer points to consider valid melting layer
detection</p>
</dd>
<dt><strong>wlength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">length of the window to select the azimuth angles used to compute the
melting layer limits at a particular azimuth [degree]</p>
</dd>
<dt><strong>percentile_bottom, percentile_top</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float [0,1]</span></dt>
<dd><p class="first last">percentile of ml points above which is considered that the bottom of
the melting layer starts and the top ends</p>
</dd>
<dt><strong>interpol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to interpolate the obtained results in order to get a value
for each azimuth</p>
</dd>
<dt><strong>time_nodata_allowed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum time allowed for no data before considering the melting
layer not valid [s]</p>
</dd>
<dt><strong>refl_field, zdr_field, rhv_field, temp_field, iso0_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Inputs. Field names within the radar object which represent the
horizonal reflectivity, the differential reflectivity, the copolar
correlation coefficient, the temperature and the height respect to the
iso0 fields. A value of None for any of these parameters will use the
default field name as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>ml_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Output. Field name which represents the melting layer field.
A value of None will use the default field name as defined in the
Py-ART configuration file.</p>
</dd>
<dt><strong>ml_pos_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Output. Field name which represents the melting layer top and bottom
height field. A value of None will use the default field name as
defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>temp_ref</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the field use as reference for temperature. Can be temperature
or height_over_iso0.
If None, it excludes model data from the algorithm.</p>
</dd>
<dt><strong>get_iso0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">returns height w.r.t. freezing level top for each gate in the radar
volume.</p>
</dd>
<dt><strong>ml_global :</strong></dt>
<dd><p class="first last">stack of previous volume data to introduce some time dependency. Its
max size is controlled by the nVol parameter. It is always in
(pseudo-)RHI mode.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Giangrande, S.E., Krause, J.M., Ryzhkov, A.V.: Automatic Designation of
the Melting Layer with a Polarimetric Prototype of the WSR-88D Radar,
J. of Applied Meteo. and Clim., 47, 1354-1364, doi:10.1175/2007JAMC1634.1,
2008</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.melting_layer_hydroclass">
<code class="descclassname">pyart.retrieve.</code><code class="descname">melting_layer_hydroclass</code><span class="sig-paren">(</span><em>radar</em>, <em>hydro_field=None</em>, <em>ml_field=None</em>, <em>ml_pos_field=None</em>, <em>iso0_field=None</em>, <em>force_continuity=True</em>, <em>dist_max=350.0</em>, <em>get_iso0=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/ml.html#melting_layer_hydroclass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.melting_layer_hydroclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the results of the hydrometeor classification by Besic et al.
estimates the position of the range gates respect to the melting layer,
the melting layer top and bottom height and the distance of the range
gate with respect to the freezing level.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object.  Must have and hydrometeor classification field</p>
</dd>
<dt><strong>hydro_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the hydrometeor classification field. A value
of None will use the default field name as defined in the Py-ART
configuration file.</p>
</dd>
<dt><strong>ml_field, ml_pos_field, iso0_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the melting layer, melting layer heightand iso0 field.
A value of None for any of these parameters will use the default field
names as defined in the Py-ART configuration file.</p>
</dd>
<dt><strong>force_continuity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Bool</span></dt>
<dd><p class="first last">If True, the melting layer is forced to be continuous in range</p>
</dd>
<dt><strong>dist_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum distance between range gates flagged as inside the melting
layer to consider them as gates in the melting layer.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ml_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">radar-like object</span></dt>
<dd><p class="first last">A radar-like object containing the field melting layer height with
the bottom (at range position 0) and top (at range position one) of
the melting layer at each ray</p>
</dd>
<dt><strong>ml_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">A dictionary containg the position of the range gate respect to the
melting layer and metadata</p>
</dd>
<dt><strong>iso0_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict or None</span></dt>
<dd><p class="first last">A dictionary containing the distance respect to the melting layer
and metadata</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.quasi_vertical_profile">
<code class="descclassname">pyart.retrieve.</code><code class="descname">quasi_vertical_profile</code><span class="sig-paren">(</span><em>radar</em>, <em>desired_angle=None</em>, <em>fields=None</em>, <em>gatefilter=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/qvp.html#quasi_vertical_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.quasi_vertical_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Quasi Vertical Profile.</p>
<p>Creates a QVP object containing fields from a radar object that can
be used to plot and produce the quasi vertical profile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Radar field to use for QVP calculation.</p>
</dd>
<dt><strong>desired_angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radar tilt angle to use for indexing radar field data.
None will result in wanted_angle = 20.0</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qvp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictonary</span></dt>
<dd><p class="first last">A quasi vertical profile object containing fields
from a radar object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter</span></dt>
<dd><p class="first last">A GateFilter indicating radar gates that should be excluded
from the import qvp calculation</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Troemel, S., M. Kumjian, A. Ryzhkov, and C. Simmer, 2013: Backscatter
differential phase - estimation and variability. J Appl. Meteor. Clim..
52, 2529 - 2548.</p>
<p>Troemel, S., A. Ryzhkov, P. Zhang, and C. Simmer, 2014: Investigations
of backscatter differential phase in the melting layer. J. Appl. Meteorol.
Clim. 54, 2344 - 2359.</p>
<p>Ryzhkov, A., P. Zhang, H. Reeves, M. Kumjian, T. Tschallener, S. Tromel,
C. Simmer, 2015: Quasi-vertical profiles - a new way to look at polarimetric
radar data. Submitted to J. Atmos. Oceanic Technol.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.steiner_conv_strat">
<code class="descclassname">pyart.retrieve.</code><code class="descname">steiner_conv_strat</code><span class="sig-paren">(</span><em>grid</em>, <em>dx=None</em>, <em>dy=None</em>, <em>intense=42.0</em>, <em>work_level=3000.0</em>, <em>peak_relation='default'</em>, <em>area_relation='medium'</em>, <em>bkg_rad=11000.0</em>, <em>use_intense=True</em>, <em>fill_value=None</em>, <em>refl_field=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/echo_class.html#steiner_conv_strat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.steiner_conv_strat" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition reflectivity into convective-stratiform using the Steiner et
al. (1995) algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Grid</span></dt>
<dd><p class="first last">Grid containing reflectivity field to partition.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>eclass</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Steiner convective-stratiform classification dictionary.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>dx, dy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The x- and y-dimension resolutions in meters, respectively.  If None
the resolution is determined from the first two axes values.</p>
</dd>
<dt><strong>intense</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The intensity value in dBZ. Grid points with a reflectivity
value greater or equal to the intensity are automatically
flagged as convective. See reference for more information.</p>
</dd>
<dt><strong>work_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The working level (separation altitude) in meters. This is the height
at which the partitioning will be done, and should minimize bright band
contamination. See reference for more information.</p>
</dd>
<dt><strong>peak_relation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘default’ or ‘sgp’</span></dt>
<dd><p class="first last">The peakedness relation. See reference for more information.</p>
</dd>
<dt><strong>area_relation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘small’, ‘medium’, ‘large’, or ‘sgp’</span></dt>
<dd><p class="first last">The convective area relation. See reference for more information.</p>
</dd>
<dt><strong>bkg_rad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The background radius in meters. See reference for more information.</p>
</dd>
<dt><strong>use_intense</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True to use the intensity criteria.</p>
</dd>
<dt><strong>fill_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Missing value used to signify bad data points. A value of None
will use the default fill value as defined in the Py-ART
configuration file.</p>
</dd>
<dt><strong>refl_field</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Field in grid to use as the reflectivity during partitioning. None
will use the default reflectivity field name from the Py-ART
configuration file.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Steiner, M. R., R. A. Houze Jr., and S. E. Yuter, 1995: Climatological
Characterization of Three-Dimensional Storm Structure from Operational
Radar and Rain Gauge Data. J. Appl. Meteor., 34, 1978-2007.</p>
</dd></dl>

<dl class="function">
<dt id="pyart.retrieve.velocity_azimuth_display">
<code class="descclassname">pyart.retrieve.</code><code class="descname">velocity_azimuth_display</code><span class="sig-paren">(</span><em>radar</em>, <em>vel_field=None</em>, <em>z_want=None</em>, <em>gatefilter=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/retrieve/vad.html#velocity_azimuth_display"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.retrieve.velocity_azimuth_display" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity azimuth display.</p>
<p>Creates a VAD object containing U Wind, V Wind and height that
can then be used to plot and produce the velocity azimuth display.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar object used.</p>
</dd>
<dt><strong>velocity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Velocity field to use for VAD calculation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vad: HorizontalWindProfile</strong></dt>
<dd><p class="first last">A velocity azimuth display object containing height, speed, direction,
u_wind, v_wind from a radar object.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>z_want</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Heights for where to sample vads from.
None will result in np.linespace(0, 10000, 100).</p>
</dd>
<dt><strong>gatefilter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter</span></dt>
<dd><p class="first last">A GateFilter indicating radar gates that should be excluded
from the import vad calculation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyart-mch 0.1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, meteoswiss-mdr.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>