
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Mapping (pyart.map) &#8212; pyart-mch 0.4.1 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyart-mch 0.4.1 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/map.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <hr class="docutils" />
<span class="target" id="module-pyart.map"></span><div class="section" id="mapping-pyart-map">
<h1>Mapping (<a class="reference internal" href="#module-pyart.map" title="pyart.map"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyart.map</span></code></a>)<a class="headerlink" href="#mapping-pyart-map" title="Permalink to this headline">¶</a></h1>
<p>Py-ART has a robust function for mapping radar data from the collected radar
coordinates to Cartesian coordinates.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pyart.map.grid_from_radars" title="pyart.map.grid_from_radars"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_from_radars</span></code></a>(radars,&nbsp;grid_shape,&nbsp;grid_limits)</td>
<td>Map one or more radars to a Cartesian grid returning a Grid object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.map.map_to_grid" title="pyart.map.map_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_to_grid</span></code></a>(radars,&nbsp;grid_shape,&nbsp;grid_limits)</td>
<td>Map one or more radars to a Cartesian grid.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.map.map_gates_to_grid" title="pyart.map.map_gates_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_gates_to_grid</span></code></a>(radars,&nbsp;grid_shape,&nbsp;…[,&nbsp;…])</td>
<td>Map gates from one or more radars to a Cartesian grid.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.map.example_roi_func_constant" title="pyart.map.example_roi_func_constant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">example_roi_func_constant</span></code></a>(zg,&nbsp;yg,&nbsp;xg)</td>
<td>Example RoI function which returns a constant radius.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pyart.map.example_roi_func_dist" title="pyart.map.example_roi_func_dist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">example_roi_func_dist</span></code></a>(zg,&nbsp;yg,&nbsp;xg)</td>
<td>Example RoI function which returns a radius which grows with distance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pyart.map.example_roi_func_dist_beam" title="pyart.map.example_roi_func_dist_beam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">example_roi_func_dist_beam</span></code></a>(zg,&nbsp;yg,&nbsp;xg)</td>
<td>Example RoI function which returns a radius which grows with distance and whose parameters are based on virtual beam size.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="pyart.map.example_roi_func_constant">
<code class="descclassname">pyart.map.</code><code class="descname">example_roi_func_constant</code><span class="sig-paren">(</span><em>zg</em>, <em>yg</em>, <em>xg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/grid_mapper.html#example_roi_func_constant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.example_roi_func_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>Example RoI function which returns a constant radius.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>zg, yg, xg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Distance from the grid center in meters for the x, y and z axes.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>roi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radius of influence in meters</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.map.example_roi_func_dist">
<code class="descclassname">pyart.map.</code><code class="descname">example_roi_func_dist</code><span class="sig-paren">(</span><em>zg</em>, <em>yg</em>, <em>xg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/grid_mapper.html#example_roi_func_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.example_roi_func_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Example RoI function which returns a radius which grows with distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>zg, yg, xg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Distance from the grid center in meters for the x, y and z axes.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>roi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.map.example_roi_func_dist_beam">
<code class="descclassname">pyart.map.</code><code class="descname">example_roi_func_dist_beam</code><span class="sig-paren">(</span><em>zg</em>, <em>yg</em>, <em>xg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/grid_mapper.html#example_roi_func_dist_beam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.example_roi_func_dist_beam" title="Permalink to this definition">¶</a></dt>
<dd><p>Example RoI function which returns a radius which grows with distance
and whose parameters are based on virtual beam size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>zg, yg, xg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Distance from the grid center in meters for the x, y and z axes.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>roi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.map.get_earth_radius">
<code class="descclassname">pyart.map.</code><code class="descname">get_earth_radius</code><span class="sig-paren">(</span><em>latitude</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/polar_to_cartesian.html#get_earth_radius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.get_earth_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the earth radius for a given latitude</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>latitude: latitude in degrees (WGS84)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>earth_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">the radius of the earth at the given latitude</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyart.map.grid_from_radars">
<code class="descclassname">pyart.map.</code><code class="descname">grid_from_radars</code><span class="sig-paren">(</span><em>radars</em>, <em>grid_shape</em>, <em>grid_limits</em>, <em>gridding_algo='map_gates_to_grid'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/grid_mapper.html#grid_from_radars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.grid_from_radars" title="Permalink to this definition">¶</a></dt>
<dd><p>Map one or more radars to a Cartesian grid returning a Grid object.</p>
<p>Additional arguments are passed to <a class="reference internal" href="#pyart.map.map_to_grid" title="pyart.map.map_to_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_to_grid()</span></code></a> or
<a class="reference internal" href="#pyart.map.map_gates_to_grid" title="pyart.map.map_gates_to_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_gates_to_grid()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radars</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar or tuple of Radar objects.</span></dt>
<dd><p class="first last">Radar objects which will be mapped to the Cartesian grid.</p>
</dd>
<dt><strong>grid_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-tuple of floats</span></dt>
<dd><p class="first last">Number of points in the grid (z, y, x).</p>
</dd>
<dt><strong>grid_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-tuple of 2-tuples</span></dt>
<dd><p class="first last">Minimum and maximum grid location (inclusive) in meters for the
z, y, x coordinates.</p>
</dd>
<dt><strong>gridding_algo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘map_to_grid’ or ‘map_gates_to_grid’</span></dt>
<dd><p class="first last">Algorithm to use for gridding. ‘map_to_grid’ finds all gates within
a radius of influence for each grid point, ‘map_gates_to_grid’ maps
each radar gate onto the grid using a radius of influence and is
typically significantly faster.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Grid</span></dt>
<dd><p class="first last">A <code class="xref py py-class docutils literal notranslate"><span class="pre">pyart.io.Grid</span></code> object containing the gridded radar
data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#pyart.map.map_to_grid" title="pyart.map.map_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_to_grid</span></code></a></dt>
<dd>Map to grid and return a dictionary of radar fields.</dd>
<dt><a class="reference internal" href="#pyart.map.map_gates_to_grid" title="pyart.map.map_gates_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_gates_to_grid</span></code></a></dt>
<dd>Map each gate onto a grid returning a dictionary of radar fields.</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>Barnes S., 1964: A Technique for Maximizing Details in Numerical Weather
Map Analysis. Journal of Applied Meteorology and Climatology, 3(4),
396-409.</p>
<p>Cressman G., 1959: An operational objective analysis system. Monthly
Weather Review, 87(10), 367-374.</p>
<p>Pauley, P. M. and X. Wu, 1990: The theoretical, discrete, and actual
response of the Barnes objective analysis scheme for one- and
two-dimensional fields. Monthly Weather Review, 118, 1145-1164</p>
</dd></dl>

<dl class="function">
<dt id="pyart.map.map_gates_to_grid">
<code class="descclassname">pyart.map.</code><code class="descname">map_gates_to_grid</code><span class="sig-paren">(</span><em>radars</em>, <em>grid_shape</em>, <em>grid_limits</em>, <em>grid_origin=None</em>, <em>grid_origin_alt=None</em>, <em>grid_projection=None</em>, <em>fields=None</em>, <em>gatefilters=False</em>, <em>map_roi=True</em>, <em>weighting_function='Barnes'</em>, <em>toa=17000.0</em>, <em>roi_func='dist_beam'</em>, <em>constant_roi=None</em>, <em>z_factor=0.05</em>, <em>xy_factor=0.02</em>, <em>min_radius=500.0</em>, <em>h_factor=1.0</em>, <em>nb=1.5</em>, <em>bsp=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/gates_to_grid.html#map_gates_to_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.map_gates_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map gates from one or more radars to a Cartesian grid.</p>
<p>Generate a Cartesian grid of points for the requested fields from the
collected points from one or more radars. For each radar gate that is not
filtered a radius of influence is calculated. The weighted field values
for that gate are added to all grid points within that radius. This
routine scaled linearly with the number of radar gates and the effective
grid size.</p>
<p>Parameters not defined below are identical to those in
<a class="reference internal" href="#pyart.map.map_to_grid" title="pyart.map.map_to_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">map_to_grid()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>roi_func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or RoIFunction</span></dt>
<dd><p class="first">Radius of influence function. A function which takes an
z, y, x grid location, in meters, and returns a radius (in meters)
within which all collected points will be included in the weighting
for that grid points. Examples can be found in the
Typically following strings can use to specify a built in
radius of influence function:</p>
<blockquote>
<div><ul class="simple">
<li>constant: constant radius of influence.</li>
<li>dist: radius grows with the distance from each radar.</li>
<li>dist_beam: radius grows with the distance from each radar
and parameter are based of virtual beam sizes.</li>
</ul>
</div></blockquote>
<p class="last">A custom RoIFunction can be defined using the RoIFunction class
and defining a get_roi method which returns the radius. For efficient
mapping this class should be implemented in Cython.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>grids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of mapped fields. The keys of the dictionary are given by
parameter fields. Each elements is a <cite>grid_size</cite> float64 array
containing the interpolated grid for that field.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#pyart.map.grid_from_radars" title="pyart.map.grid_from_radars"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_from_radars</span></code></a></dt>
<dd>Map to a grid and return a Grid object</dd>
<dt><a class="reference internal" href="#pyart.map.map_to_grid" title="pyart.map.map_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">map_to_grid</span></code></a></dt>
<dd>Create grid by finding the radius of influence around each grid point.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="pyart.map.map_to_grid">
<code class="descclassname">pyart.map.</code><code class="descname">map_to_grid</code><span class="sig-paren">(</span><em>radars</em>, <em>grid_shape</em>, <em>grid_limits</em>, <em>grid_origin=None</em>, <em>grid_origin_alt=None</em>, <em>grid_projection=None</em>, <em>fields=None</em>, <em>gatefilters=False</em>, <em>map_roi=True</em>, <em>weighting_function='Barnes'</em>, <em>toa=17000.0</em>, <em>copy_field_data=True</em>, <em>algorithm='kd_tree'</em>, <em>leafsize=10.0</em>, <em>roi_func='dist_beam'</em>, <em>constant_roi=None</em>, <em>z_factor=0.05</em>, <em>xy_factor=0.02</em>, <em>min_radius=500.0</em>, <em>h_factor=1.0</em>, <em>nb=1.5</em>, <em>bsp=1.0</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/grid_mapper.html#map_to_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.map_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Map one or more radars to a Cartesian grid.</p>
<p>Generate a Cartesian grid of points for the requested fields from the
collected points from one or more radars. The field value for a grid
point is found by interpolating from the collected points within a given
radius of influence and weighting these nearby points according to their
distance from the grid points. Collected points are filtered
according to a number of criteria so that undesired points are not
included in the interpolation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radars</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar or tuple of Radar objects.</span></dt>
<dd><p class="first last">Radar objects which will be mapped to the Cartesian grid.</p>
</dd>
<dt><strong>grid_shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-tuple of floats</span></dt>
<dd><p class="first last">Number of points in the grid (z, y, x).</p>
</dd>
<dt><strong>grid_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">3-tuple of 2-tuples</span></dt>
<dd><p class="first last">Minimum and maximum grid location (inclusive) in meters for the
z, y, x coordinates.</p>
</dd>
<dt><strong>grid_origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(float, float) or None</span></dt>
<dd><p class="first last">Latitude and longitude of grid origin. None sets the origin
to the location of the first radar.</p>
</dd>
<dt><strong>grid_origin_alt: float or None</strong></dt>
<dd><p class="first last">Altitude of grid origin, in meters. None sets the origin
to the location of the first radar.</p>
</dd>
<dt><strong>grid_projection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dic or str</span></dt>
<dd><p class="first last">Projection parameters defining the map projection used to transform the
locations of the radar gates in geographic coordinate to Cartesian
coodinates. None will use the default dictionary which uses a native
azimutal equidistance projection. See <a class="reference internal" href="core.html#pyart.core.Grid" title="pyart.core.Grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyart.core.Grid()</span></code></a> for
additional details on this parameter. The geographic coordinates of
the radar gates are calculated using the projection defined for each
radar. No transformation is used if a grid_origin and grid_origin_alt
are None and a single radar is specified.</p>
</dd>
<dt><strong>fields</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or None</span></dt>
<dd><p class="first last">List of fields within the radar objects which will be mapped to
the cartesian grid. None, the default, will map the fields which are
present in all the radar objects.</p>
</dd>
<dt><strong>gatefilters</strong> <span class="classifier-delimiter">:</span> <span class="classifier">GateFilter, tuple of GateFilter objects, optional</span></dt>
<dd><p class="first last">Specify what gates from each radar will be included in the
interpolation onto the grid. Only gates specified in each gatefilters
will be included in the mapping to the grid. A single GateFilter can
be used if a single Radar is being mapped. A value of False for a
specific element or the entire parameter will apply no filtering of
gates for a specific radar or all radars (the default).
Similarily a value of None will create a GateFilter from the
radar moments using any additional arguments by passing them to
<code class="xref py py-func docutils literal notranslate"><span class="pre">moment_based_gate_filter()</span></code>.</p>
</dd>
<dt><strong>roi_func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or function</span></dt>
<dd><p class="first">Radius of influence function. A functions which takes an
z, y, x grid location, in meters, and returns a radius (in meters)
within which all collected points will be included in the weighting
for that grid points. Examples can be found in the
<a class="reference internal" href="#pyart.map.example_roi_func_constant" title="pyart.map.example_roi_func_constant"><code class="xref py py-func docutils literal notranslate"><span class="pre">example_roi_func_constant()</span></code></a>,
<a class="reference internal" href="#pyart.map.example_roi_func_dist" title="pyart.map.example_roi_func_dist"><code class="xref py py-func docutils literal notranslate"><span class="pre">example_roi_func_dist()</span></code></a>, and
<a class="reference internal" href="#pyart.map.example_roi_func_dist_beam" title="pyart.map.example_roi_func_dist_beam"><code class="xref py py-func docutils literal notranslate"><span class="pre">example_roi_func_dist_beam()</span></code></a>.
Alternatively the following strings can use to specify a built in
radius of influence function:</p>
<blockquote>
<div><ul class="simple">
<li>constant: constant radius of influence.</li>
<li>dist: radius grows with the distance from each radar.</li>
<li>dist_beam: radius grows with the distance from each radar
and parameter are based of virtual beam sizes.</li>
</ul>
</div></blockquote>
<p class="last">The parameters which control these functions are listed in the
<cite>Other Parameters</cite> section below.</p>
</dd>
<dt><strong>map_roi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True to include a radius of influence field in the returned
dictionary under the ‘ROI’ key. This is the value of roi_func at all
grid points.</p>
</dd>
<dt><strong>weighting_function</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘Barnes’ or ‘Barnes2’ or ‘Cressman’ or ‘Nearest’</span></dt>
<dd><p class="first last">Functions used to weight nearby collected points when interpolating a
grid point.</p>
</dd>
<dt><strong>toa</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Top of atmosphere in meters. Collected points above this height are
not included in the interpolation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>grids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of mapped fields. The keys of the dictionary are given by
parameter fields. Each elements is a <cite>grid_size</cite> float64 array
containing the interpolated grid for that field.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><dl class="first last docutils">
<dt><strong>constant_roi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radius of influence parameter for the built in ‘constant’ function.
This parameter is the constant radius in meter for all grid points.
This parameter is used when <cite>roi_func</cite> is <cite>constant</cite> or constant_roi
is not None. If constant_roi is not None, the constant roi_func is
used automatically.</p>
</dd>
<dt><strong>z_factor, xy_factor, min_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radius of influence parameters for the built in ‘dist’ function.
The parameter correspond to the radius size increase, in meters,
per meter increase in the z-dimension from the nearest radar,
the same foreach meteter in the xy-distance from the nearest radar,
and the minimum radius of influence in meters. These parameters are
only used when <cite>roi_func</cite> is ‘dist’.</p>
</dd>
<dt><strong>h_factor, nb, bsp, min_radius</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Radius of influence parameters for the built in ‘dist_beam’ function.
The parameter correspond to the height scaling, virtual beam width,
virtual beam spacing, and minimum radius of influence. These
parameters are only used when <cite>roi_func</cite> is ‘dist_mean’.</p>
</dd>
<dt><strong>copy_field_data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True to copy the data within the radar fields for faster gridding,
the dtype for all fields in the grid will be float64. False will not
copy the data which preserves the dtype of the fields in the grid,
may use less memory but results in significantly slower gridding
times. When False gates which are masked in a particular field but
are not masked in the <cite>refl_field</cite> field will still be included in
the interpolation. This can be prevented by setting this parameter
to True or by gridding each field individually setting the
<cite>refl_field</cite> parameter and the <cite>fields</cite> parameter to the field in
question. It is recommended to set this parameter to True.</p>
</dd>
<dt><strong>algorithm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘kd_tree’.</span></dt>
<dd><p class="first last">Algorithms to use for finding the nearest neighbors. ‘kd_tree’ is the
only valid option.</p>
</dd>
<dt><strong>leafsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Leaf size passed to the neighbor lookup tree. This can affect the
speed of the construction and query, as well as the memory required
to store the tree. The optimal value depends on the nature of the
problem. This value should only effect the speed of the gridding,
not the results.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#pyart.map.grid_from_radars" title="pyart.map.grid_from_radars"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_from_radars</span></code></a></dt>
<dd>Map to grid and return a Grid object.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="pyart.map.polar_to_cartesian">
<code class="descclassname">pyart.map.</code><code class="descname">polar_to_cartesian</code><span class="sig-paren">(</span><em>radar_sweep</em>, <em>field_name</em>, <em>cart_res=75</em>, <em>max_range=None</em>, <em>mapping=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pyart/map/polar_to_cartesian.html#polar_to_cartesian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyart.map.polar_to_cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates a PPI or RHI scan in polar coordinates to a regular cartesian
grid of South-North and West-East coordinates (for PPI) or distance at
ground and altitude coordinates (for RHI)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>radar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Radar</span></dt>
<dd><p class="first last">Radar instance as generated py pyart</p>
</dd>
<dt><strong>sweep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Sweep number to project to cartesian coordinates.</p>
</dd>
<dt><strong>field_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the radar field to be interpolated</p>
</dd>
<dt><strong>cart_res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Resolution (in m.) of the cartesian grid to which polar data is
interpolated</p>
</dd>
<dt><strong>max_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Maximal allowed range (in m.) from radar for gates to be interpolated</p>
</dd>
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Dictionnary of mapping indexes (from polar to cartesian), gets returned
by the function (see below). Can be used as input when interpolating
sequentially several variables for the same scan, to save significant
time</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coords</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of 2 arrays</span></dt>
<dd><p class="first last">2D coordinates of the cartesian grid</p>
</dd>
<dt><strong>cart_data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd><p class="first last">Interpolated radar measurements (on the cartesian grid)</p>
</dd>
<dt>mapping,: dict</dt>
<dd><p class="first last">Dictionnary of mapping indexes (from polar to cartesian),which contains
the indexes mapping the polar grid to the cartesian grid as well as some
metadata.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyart-mch 0.4.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, meteoswiss-mdr.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>